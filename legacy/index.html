<!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Orion EWS Monitor</title>
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  >
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <link rel="stylesheet" href="assets/map-styles.css">
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      min-height: 100vh;
      height: 100vh;
      background: radial-gradient(circle at top, #0ea5e9 0, #0f172a 40%, #020617 100%);
      color: #e5e7eb;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      padding: 24px 16px;
      overflow: hidden;
    }

    .app-shell {
      width: 100%;
      max-width: 100%;
      height: 100%;
      background: rgba(15, 23, 42, 0.8);
      border-radius: 24px;
      border: 1px solid rgba(148, 163, 184, 0.35);
      box-shadow:
        0 24px 80px rgba(15, 23, 42, 0.9),
        0 0 0 1px rgba(15, 23, 42, 0.9);
      backdrop-filter: blur(18px);
      overflow: hidden;
      display: grid;
      grid-template-rows: auto 1fr;
    }

    header {
      padding: 18px 22px 14px;
      display: flex;
      flex-wrap: wrap;
      gap: 12px 20px;
      align-items: center;
      justify-content: space-between;
      border-bottom: 1px solid rgba(148, 163, 184, 0.35);
      background: linear-gradient(to right, rgba(15, 23, 42, 0.85), rgba(8, 47, 73, 0.95));
    }

    .title-group {
      display: flex;
      flex-direction: column;
      gap: 3px;
    }

    h1 {
      font-size: 1.25rem;
      font-weight: 600;
      letter-spacing: 0.03em;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .badge {
      font-size: 0.65rem;
      text-transform: uppercase;
      letter-spacing: 0.14em;
      padding: 3px 10px;
      border-radius: 999px;
      background: radial-gradient(circle at 0 0, #22d3ee, #1d4ed8);
      color: #e5e7eb;
      border: 1px solid rgba(15, 23, 42, 0.8);
      box-shadow: 0 0 0 1px rgba(15, 23, 42, 0.7), 0 6px 16px rgba(15, 23, 42, 0.9);
    }

    .app-logo {
      height: 2.1rem;
      width: auto;
      border-radius: 10px;
      object-fit: contain;
      box-shadow:
        0 0 0 1px rgba(15, 23, 42, 0.9),
        0 8px 18px rgba(15, 23, 42, 0.9);
    }

    .subtitle {
      font-size: 0.8rem;
      color: #cbd5f5;
      opacity: 0.9;
    }

    .controls {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }

    .admin-link {
      font-size: 0.76rem;
      padding: 5px 11px;
      border-radius: 6px;
      border: 1px solid rgba(148, 163, 184, 0.6);
      color: #e5e7eb;
      text-decoration: none;
      background: radial-gradient(circle at 0 0, rgba(15, 118, 110, 0.5), rgba(15, 23, 42, 0.98));
      display: inline-flex;
      align-items: center;
      gap: 6px;
      transition: background 150ms ease, border-color 150ms ease, transform 120ms ease;
    }

    .admin-link:hover {
      background: radial-gradient(circle at 0 0, rgba(45, 212, 191, 0.9), rgba(15, 23, 42, 0.98));
      border-color: rgba(45, 212, 191, 0.9);
      transform: translateY(-0.5px);
    }

    .status-chip {
      font-size: 0.7rem;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid rgba(56, 189, 248, 0.5);
      color: #7dd3fc;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      background: radial-gradient(circle at 0 0, rgba(56, 189, 248, 0.22), rgba(15, 23, 42, 0.95));
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: radial-gradient(circle at 0 0, #22c55e, #16a34a);
      box-shadow: 0 0 0 3px rgba(34, 197, 94, 0.12);
    }

    .refresh-button {
      position: relative;
      border-radius: 6px;
      border: 1px solid rgba(59, 130, 246, 0.9);
      background: radial-gradient(circle at 0 0, rgba(59, 130, 246, 0.9), rgba(8, 47, 73, 0.9));
      color: #eff6ff;
      padding: 6px 14px;
      font-size: 0.8rem;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      transition: transform 150ms ease, box-shadow 150ms ease, background 200ms ease;
      box-shadow:
        0 0 0 1px rgba(15, 23, 42, 0.9),
        0 18px 35px rgba(37, 99, 235, 0.6);
      outline: none;
    }

    .refresh-button:hover {
      transform: translateY(-1px) scale(1.01);
      box-shadow:
        0 0 0 1px rgba(15, 23, 42, 0.9),
        0 20px 40px rgba(37, 99, 235, 0.8);
      background: radial-gradient(circle at 0 0, rgba(96, 165, 250, 1), rgba(8, 47, 73, 0.95));
    }

    .refresh-button:active {
      transform: translateY(0) scale(0.99);
      box-shadow:
        0 0 0 1px rgba(15, 23, 42, 0.9),
        0 10px 25px rgba(37, 99, 235, 0.75);
    }

    .refresh-icon {
      width: 13px;
      height: 13px;
      border-radius: 999px;
      border: 2px solid rgba(219, 234, 254, 0.85);
      border-top-color: transparent;
      border-right-color: transparent;
      transform: rotate(-45deg);
    }

    .refresh-button[disabled] {
      cursor: default;
      opacity: 0.7;
      box-shadow:
        0 0 0 1px rgba(15, 23, 42, 0.9),
        0 10px 25px rgba(15, 23, 42, 0.9);
    }

    .content {
      display: grid;
      grid-template-columns: minmax(0, 2.7fr) minmax(260px, 1.3fr);
      height: 100%;
      min-height: 0;
    }

    .ews-popup {
      position: relative;
      min-width: 220px;
      max-width: 280px;
      padding: 10px 12px 11px;
      border-radius: 18px;
      border: 1px solid rgba(148, 163, 184, 0.4);
      background:
        radial-gradient(circle at 0 0, rgba(59, 130, 246, 0.22), transparent 55%),
        radial-gradient(circle at 100% 0, rgba(45, 212, 191, 0.18), transparent 55%),
        rgba(15, 23, 42, 0.96);
      box-shadow:
        0 18px 40px rgba(15, 23, 42, 0.85),
        0 0 0 1px rgba(15, 23, 42, 0.9);
      color: #e5e7eb;
      backdrop-filter: blur(16px);
    }

    .ews-popup-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 8px;
      margin-bottom: 8px;
    }

    .ews-popup-title {
      font-size: 0.9rem;
      font-weight: 600;
      color: #f9fafb;
    }

    .ews-popup-chip {
      font-size: 0.65rem;
      padding: 3px 8px;
      border-radius: 10px;
      background: radial-gradient(circle at 0 0, #22d3ee, #0ea5e9);
      color: #f9fafb;
      border: 1px solid rgba(15, 23, 42, 0.8);
      white-space: nowrap;
    }

    .ews-popup-body {
      display: grid;
      grid-template-columns: auto 1fr;
      gap: 4px 12px;
      align-items: center;
    }

    .ews-popup-level {
      grid-row: span 2;
      text-align: center;
      padding: 4px 8px;
      border-radius: 10px;
      background: radial-gradient(circle at 0 0, rgba(56, 189, 248, 0.3), rgba(15, 23, 42, 0.95));
      border: 1px solid rgba(56, 189, 248, 0.7);
      min-width: 68px;
    }

    .ews-popup-level-value {
      display: block;
      font-size: 1.3rem;
      font-weight: 700;
      line-height: 1.1;
    }

    .ews-popup-level-unit {
      font-size: 0.7rem;
      color: #bfdbfe;
    }

    .ews-popup-status-pill {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 4px 9px;
      border-radius: 10px;
      font-size: 0.72rem;
      font-weight: 600;
      letter-spacing: 0.03em;
      text-transform: uppercase;
    }

    .ews-popup-status-normal {
      background: rgba(34, 197, 94, 0.1);
      color: #bbf7d0;
      border: 1px solid rgba(34, 197, 94, 0.7);
    }

    .ews-popup-status-waspada {
      background: rgba(234, 179, 8, 0.12);
      color: #fef9c3;
      border: 1px solid rgba(234, 179, 8, 0.8);
    }

    .ews-popup-status-siaga {
      background: rgba(249, 115, 22, 0.14);
      color: #fed7aa;
      border: 1px solid rgba(249, 115, 22, 0.85);
    }

    .ews-popup-status-bahaya {
      background: rgba(239, 68, 68, 0.16);
      color: #fecaca;
      border: 1px solid rgba(239, 68, 68, 0.9);
      box-shadow: 0 0 0 1px rgba(239, 68, 68, 0.5);
    }

    .ews-popup-meta {
      font-size: 0.7rem;
      color: #9ca3af;
      line-height: 1.35;
      margin-top: 4px;
    }

    .ews-popup-meta strong {
      color: #e5e7eb;
      font-weight: 500;
    }

    .ews-popup-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 8px;
    }

    .ews-control-button {
      font-size: 0.68rem;
      border-radius: 6px;
      border: 1px solid rgba(148, 163, 184, 0.6);
      padding: 3px 9px;
      background: rgba(15, 23, 42, 0.95);
      color: #e5e7eb;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 4px;
      transition: background 150ms ease, border-color 150ms ease, transform 120ms ease;
    }

    .ews-control-button:hover {
      background: rgba(30, 64, 175, 0.9);
      border-color: rgba(129, 140, 248, 0.9);
      transform: translateY(-0.5px);
    }

    .ews-control-button:active {
      transform: translateY(0.5px);
    }

    .ews-control-button[disabled] {
      opacity: 0.7;
      cursor: default;
    }

    .leaflet-popup-content-wrapper {
      border-radius: 16px;
      padding: 0;
      background: rgba(15, 23, 42, 0.96);
      border: 1px solid rgba(148, 163, 184, 0.5);
      box-shadow:
        0 18px 40px rgba(15, 23, 42, 0.9),
        0 0 0 1px rgba(15, 23, 42, 0.9);
      color: #e5e7eb;
    }

    .leaflet-popup-tip {
      background: rgba(15, 23, 42, 0.96);
      border: 1px solid rgba(148, 163, 184, 0.5);
    }

    .leaflet-popup-content {
      margin: 8px 10px;
      font-size: 0.8rem;
      line-height: 1.4;
      color: #e5e7eb;
      max-width: 260px;
    }

    #map {
      width: 100%;
      height: 100%;
    }

    .map-shell {
      position: relative;
      height: 100%;
      overflow: hidden;
    }

    .side-panel {
      border-left: 1px solid rgba(148, 163, 184, 0.35);
      padding: 14px 16px;
      background: radial-gradient(circle at top left, rgba(15, 118, 110, 0.25), rgba(15, 23, 42, 0.95));
      display: flex;
      flex-direction: column;
      gap: 16px;
      overflow-y: auto;
    }

    .panel-section-title {
      font-size: 0.8rem;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      color: #9ca3af;
    }

    .info-block {
      font-size: 0.8rem;
      color: #e5e7eb;
      line-height: 1.4;
      border-radius: 14px;
      border: 1px solid rgba(148, 163, 184, 0.28);
      background: radial-gradient(circle at 0 0, rgba(29, 78, 216, 0.45), rgba(15, 23, 42, 0.95));
      padding: 10px 11px;
    }

    .info-block strong {
      color: #bfdbfe;
    }

    .legend {
      display: flex;
      flex-direction: column;
      gap: 8px;
      font-size: 0.8rem;
      padding: 10px 11px;
      border-radius: 14px;
      border: 1px solid rgba(148, 163, 184, 0.28);
      background: rgba(15, 23, 42, 0.95);
    }

    .legend-row {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .legend-line {
      width: 28px;
      height: 0;
      border-radius: 999px;
      border-top: 3px solid #22d3ee;
    }

    .legend-line-river {
      border-top-color: #22d3ee;
    }

    .legend-line-local-river {
      border-top-color: #0ea5e9;
    }

    .legend-line-road {
      border-top-color: #facc15;
    }

    .legend-line-contour-low {
      border-top-color: #22c55e;
    }

    .legend-line-contour-mid {
      border-top-color: #eab308;
    }

    .legend-line-contour-high {
      border-top-color: #f97316;
    }

    .legend-line-contour-very-high {
      border-top-color: #ef4444;
    }

    .legend-area {
      width: 18px;
      height: 18px;
      border-radius: 4px;
      background: rgba(56, 189, 248, 0.25);
      border: 2px solid #38bdf8;
    }

    .legend-area-building {
      background: rgba(251, 146, 60, 0.25);
      border-color: #fb923c;
    }

    .legend-area-rain-light {
      background: rgba(191, 219, 254, 0.7);
      border-color: #60a5fa;
    }

    .legend-area-rain-moderate {
      background: rgba(134, 239, 172, 0.7);
      border-color: #22c55e;
    }

    .legend-area-rain-heavy {
      background: rgba(252, 211, 77, 0.7);
      border-color: #eab308;
    }

    .legend-area-rain-very-heavy {
      background: rgba(248, 113, 113, 0.75);
      border-color: #ef4444;
    }

    .legend-area-village-alert {
      background: rgba(239, 68, 68, 0.55);
      border-color: #ef4444;
    }

    .legend-area-soil-aluvial {
      background: rgba(191, 219, 254, 0.7);
      border-color: #1d4ed8;
    }

    .legend-area-soil-regosol {
      background: rgba(254, 202, 202, 0.8);
      border-color: #b91c1c;
    }

    .legend-area-soil-mediteran {
      background: rgba(254, 249, 195, 0.85);
      border-color: #a16207;
    }

    .legend-area-soil-litosol {
      background: rgba(220, 252, 231, 0.85);
      border-color: #15803d;
    }

    .legend-area-soil-other {
      background: rgba(209, 213, 219, 0.85);
      border-color: #4b5563;
    }

    .legend-point-ews {
      width: 14px;
      height: 14px;
      border-radius: 999px;
    }

    .legend-point-ews-flood {
      border: 2px solid #0ea5e9;
      background: rgba(14, 165, 233, 0.9);
    }

    .legend-point-ews-geo {
      border: 2px solid #f97316;
      background: rgba(249, 115, 22, 0.9);
    }

    .legend-point-ews-quake {
      border: 2px solid #ef4444;
      background: rgba(239, 68, 68, 0.9);
    }

    .legend-point-ews-magma {
      border: 2px solid #a855f7;
      background: rgba(168, 85, 247, 0.9);
    }

    .legend-point-ews-weather {
      border: 2px solid #22c55e;
      background: rgba(34, 197, 94, 0.9);
    }

    .legend-point-ews-groundwater {
      border: 2px solid #3a00a6;
      background: rgba(58, 0, 166, 0.9);
    }

    .ews-icon-image {
      width: 32px;
      height: 32px;
      border-radius: 4px;
      object-fit: cover;
      display: block;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
    }

    .legend-label {
      color: #e5e7eb;
    }

    .status-box {
      font-size: 0.78rem;
      border-radius: 14px;
      border: 1px solid rgba(148, 163, 184, 0.28);
      padding: 10px 11px;
      background: rgba(15, 23, 42, 0.95);
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .status-label {
      color: #9ca3af;
    }

    .orion-link-small {
      margin-top: 6px;
      font-size: 0.75rem;
      color: #9ca3af;
    }

    .orion-link-small a {
      color: #7dd3fc;
      text-decoration: none;
    }

    .orion-link-small a:hover {
      text-decoration: underline;
    }

    .status-text {
      color: #e5e7eb;
    }

    .status-text.ok {
      color: #6ee7b7;
    }

    .status-text.loading {
      color: #facc15;
    }

    .status-text.error {
      color: #fca5a5;
    }

    .filter-group {
      margin-top: 6px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      font-size: 0.78rem;
    }

    .filter-option {
      display: flex;
      align-items: center;
      gap: 8px;
      color: #e5e7eb;
    }

    .filter-option input[type="checkbox"] {
      width: 13px;
      height: 13px;
      accent-color: #0ea5e9;
    }

    .export-button {
      margin-top: 6px;
      position: relative;
      border-radius: 6px;
      border: 1px solid rgba(45, 212, 191, 0.9);
      background: radial-gradient(circle at 0 0, rgba(34, 197, 94, 0.9), rgba(15, 118, 110, 0.95));
      color: #ecfdf5;
      padding: 6px 10px;
      font-size: 0.78rem;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      cursor: pointer;
      transition: transform 150ms ease, box-shadow 150ms ease, background 200ms ease;
      box-shadow:
        0 0 0 1px rgba(15, 23, 42, 0.9),
        0 14px 28px rgba(16, 185, 129, 0.65);
      outline: none;
    }

    .export-button:hover {
      transform: translateY(-1px) scale(1.01);
      box-shadow:
        0 0 0 1px rgba(15, 23, 42, 0.9),
        0 18px 36px rgba(16, 185, 129, 0.85);
      background: radial-gradient(circle at 0 0, rgba(45, 212, 191, 1), rgba(15, 118, 110, 1));
    }

    .export-button:active {
      transform: translateY(0) scale(0.99);
      box-shadow:
        0 0 0 1px rgba(15, 23, 42, 0.9),
        0 10px 22px rgba(16, 185, 129, 0.8);
    }

    /* Half-width buttons and controls */
    .export-button.half-width {
      width: 50%;
      min-width: 120px;
    }
    
    .status-box.half-width {
      width: 50%;
      min-width: 180px;
    }
    
    .panel-section.half-width {
      width: 50%;
    }

    .export-icon {
      width: 11px;
      height: 11px;
      border-radius: 2px;
      border: 2px solid rgba(236, 253, 245, 0.9);
      border-top: 0;
      position: relative;
    }

    .export-icon::after {
      content: "";
      position: absolute;
      left: 50%;
      top: -3px;
      width: 0;
      height: 0;
      border-left: 3px solid transparent;
      border-right: 3px solid transparent;
      border-top: 0;
      border-bottom: 5px solid rgba(236, 253, 245, 0.9);
      transform: translateX(-50%);
    }

    .footer-note {
      font-size: 0.7rem;
      color: #9ca3af;
      opacity: 0.9;
    }

    .footer-note a {
      color: #bfdbfe;
      text-decoration: none;
    }

    .footer-note a:hover {
      text-decoration: underline;
    }

    .map-loading-overlay {
      position: absolute;
      inset: 10px 14px;
      pointer-events: none;
      display: flex;
      align-items: flex-end;
      justify-content: flex-end;
    }

    .map-loading-badge {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 6px 11px;
      border-radius: 999px;
      font-size: 0.75rem;
      background: rgba(15, 23, 42, 0.92);
      border: 1px solid rgba(148, 163, 184, 0.35);
      color: #e5e7eb;
      backdrop-filter: blur(8px);
    }

    .map-loading-spinner {
      width: 13px;
      height: 13px;
      border-radius: 999px;
      border: 2px solid rgba(148, 163, 184, 0.9);
      border-top-color: transparent;
      animation: spin 650ms linear infinite;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    @media (max-width: 900px) {
      .app-shell {
        border-radius: 18px;
        height: auto;
      }

      .content {
        grid-template-columns: minmax(0, 1fr);
        grid-template-rows: minmax(360px, 1.7fr) minmax(0, 1.1fr);
      }

      .side-panel {
        border-left: none;
        border-top: 1px solid rgba(148, 163, 184, 0.35);
        overflow-y: visible;
      }
    }

    @media (max-width: 640px) {
      body {
        padding: 16px 10px;
        height: auto;
        overflow: auto;
      }

      header {
        align-items: flex-start;
      }

      h1 {
        font-size: 1.05rem;
      }
    }

    /* Geosiana Marker Styles */
    .geosiana-marker {
      font-size: 32px !important;
      font-weight: normal !important;
      display: flex !important;
      align-items: center !important;
      justify-content: center !important;
      text-align: center !important;
      background: transparent !important;
      border: none !important;
    }

    .geosiana-marker.blue {
      color: #3b82f6 !important;
      text-shadow: 0 0 3px rgba(59, 130, 246, 0.5) !important;
    }

    .geosiana-marker.red {
      color: #ef4444 !important;
      text-shadow: 0 0 3px rgba(239, 68, 68, 0.5) !important;
    }

    .geosiana-marker.yellow {
      color: #eab308 !important;
      text-shadow: 0 0 3px rgba(234, 179, 8, 0.5) !important;
    }

    /* Custom popup styles */
    .custom-popup h3 {
      margin: 0 0 8px 0;
      color: #1f2937;
      font-size: 16px;
    }

    .custom-popup p {
      margin: 4px 0;
      font-size: 14px;
    }

    .custom-popup small {
      color: #6b7280;
      font-size: 12px;
    }
  </style>
</head>
<body>
  <div class="app-shell">
    <header>
      <div class="title-group">
        <h1>
          <img src="orionweb.png" alt="Orion EWS Monitor" class="app-logo">
          <span>Orion EWS Monitor</span>
          <span class="badge">Banjarnegara Â· EWS</span>
        </h1>
        <div class="subtitle">
          Visualisasi deteksi kerawanan bencana alam Kabupaten Banjarnegara.
        </div>
      </div>
      <div class="controls">
        <div class="status-chip">
          <span class="status-dot"></span>
          Sensor Orion, BMKG, dan data geospasial terbuka
        </div>
        <button id="refreshButton" class="refresh-button">
          <span class="refresh-icon"></span>
          <span>Muat ulang peta & data sensor</span>
        </button>
        <a href="berita.html" class="admin-link" style="margin-right: 10px;">
          <i class="fas fa-newspaper" style="margin-right: 5px;"></i>Berita Bencana
        </a>
        <a href="login.php" class="admin-link">Buka halaman admin</a>
      </div>
    </header>
    <div class="content">
      <div class="map-shell">
        <div id="map"></div>
        <div id="mapLoadingOverlay" class="map-loading-overlay" style="display: none;">
          <div class="map-loading-badge">
            <div class="map-loading-spinner"></div>
            <span>Memuat geometri air permukaanâ€¦</span>
          </div>
        </div>
      </div>
      <aside class="side-panel">
        <div>
          <div class="panel-section-title">Ringkasan Pemantauan</div>
          <div class="info-block">
            <strong>Kabupaten Banjarnegara</strong><br>
            Orion EWS Monitor memadukan data sungai, hujan, elevasi, dan lokasi
            sensor EWS untuk membantu memantau potensi kerawanan bencana alam.
          </div>
        </div>
        <div>
          <div class="panel-section-title">Legenda Peta</div>
          <div class="legend">
            <div class="legend-row">
              <div class="legend-line legend-line-river"></div>
              <div class="legend-label">Sungai utama (Overpass API)</div>
            </div>
            <div class="legend-row">
              <div class="legend-line legend-line-local-river"></div>
              <div class="legend-label">Sungai (data lokal GeoJSON)</div>
            </div>
            <div class="legend-row">
              <div class="legend-line legend-line-road"></div>
              <div class="legend-label">Jalan (GeoJSON lokal)</div>
            </div>
            <div class="legend-row">
              <div class="legend-area legend-area-building"></div>
              <div class="legend-label">Bangunan (GeoJSON lokal)</div>
            </div>
            <div class="legend-row">
              <div class="legend-area legend-area-rain-light"></div>
              <div class="legend-label">Curah hujan tahunan rendah (&lt;1.000 mm/tahun)</div>
            </div>
            <div class="legend-row">
              <div class="legend-area legend-area-rain-moderate"></div>
              <div class="legend-label">Curah hujan tahunan sedang (1.000â€“2.000 mm/tahun)</div>
            </div>
            <div class="legend-row">
              <div class="legend-area legend-area-rain-heavy"></div>
              <div class="legend-label">Curah hujan tahunan tinggi (2.000â€“3.000 mm/tahun)</div>
            </div>
            <div class="legend-row">
              <div class="legend-area legend-area-rain-very-heavy"></div>
              <div class="legend-label">Curah hujan tahunan sangat tinggi (&gt;3.000 mm/tahun)</div>
            </div>
            <div class="legend-row">
              <div class="legend-point-ews legend-point-ews-flood"></div>
              <div class="legend-label">Orion FloodGuard (banjir)</div>
            </div>
            <div class="legend-row">
              <div class="legend-point-ews legend-point-ews-geo"></div>
              <div class="legend-label">Orion GeoShield (longsor)</div>
            </div>
            <div class="legend-row">
              <div class="legend-point-ews legend-point-ews-quake"></div>
              <div class="legend-label">Orion QuakeAlert (gempa)</div>
            </div>
            <div class="legend-row">
              <div class="legend-point-ews legend-point-ews-magma"></div>
              <div class="legend-label">Orion MagmaShield (gunung api)</div>
            </div>
            <div class="legend-row">
              <div class="legend-point-ews legend-point-ews-weather"></div>
              <div class="legend-label">Orion WeatherHub (cuaca)</div>
            </div>
            <div class="legend-row">
              <div class="legend-line legend-line-contour-low"></div>
              <div class="legend-line legend-line-contour-mid"></div>
              <div class="legend-line legend-line-contour-high"></div>
              <div class="legend-line legend-line-contour-very-high"></div>
              <div class="legend-label">Kontur: hijau rendah, kuning sedang, oranye tinggi, merah sangat tinggi</div>
            </div>
            <div class="legend-row">
              <div class="legend-area"></div>
              <div class="legend-label">Badan air: waduk, danau, kolam</div>
            </div>
            <div class="legend-row">
              <div class="legend-area legend-area-village-alert"></div>
              <div class="legend-label">Desa pada status siaga/bahaya (EWS)</div>
            </div>
            <div class="legend-row">
              <div class="legend-point-ews legend-point-ews-groundwater"></div>
              <div class="legend-label">Titik sumur air tanah (BIG â€“ Peta Air Tanah)</div>
            </div>
          </div>
        </div>
        <div>
          <div class="panel-section-title">Filter Layer</div>
          <div class="filter-group">
            <label class="filter-option">
              <input type="checkbox" id="filterRivers">
              <span>Sungai (gabungan data lokal dan Overpass)</span>
            </label>
            <label class="filter-option">
              <input type="checkbox" id="filterRoads">
              <span>Jalan & infrastruktur</span>
            </label>

            <label class="filter-option">
              <input type="checkbox" id="filterRain">
              <span>Curah hujan BMKG (klimatologi)</span>
            </label>
            <label class="filter-option">
              <input type="checkbox" id="filterClimateDJF">
              <span>Proyeksi iklim DJF (Desâ€“Janâ€“Feb)</span>
            </label>
            <label class="filter-option">
              <input type="checkbox" id="filterClimateMAM">
              <span>Proyeksi iklim MAM (Marâ€“Aprâ€“Mei)</span>
            </label>
            <label class="filter-option">
              <input type="checkbox" id="filterClimateJJA">
              <span>Proyeksi iklim JJA (Junâ€“Julâ€“Agt)</span>
            </label>
            <label class="filter-option">
              <input type="checkbox" id="filterClimateSON">
              <span>Proyeksi iklim SON (Sepâ€“Oktâ€“Nov)</span>
            </label>
            <label class="filter-option">
              <input type="checkbox" id="filterQuakes">
              <span>Gempa dirasakan BMKG</span>
            </label>

            <label class="filter-option">
              <input type="checkbox" id="filterSoil">
              <span>Peta jenis tanah (tanah_jateng)</span>
            </label>

            <label class="filter-option">
              <input type="checkbox" id="filterEwsFlood" checked>
              <span>Orion FloodGuard (banjir)</span>
            </label>
            <label class="filter-option">
              <input type="checkbox" id="filterEwsGeo" checked>
              <span>Orion GeoShield (longsor)</span>
            </label>
            <label class="filter-option">
              <input type="checkbox" id="filterEwsQuake" checked>
              <span>Orion QuakeAlert (gempa)</span>
            </label>
            <label class="filter-option">
              <input type="checkbox" id="filterEwsMagma" checked>
              <span>Orion MagmaShield (gunung api)</span>
            </label>
            <label class="filter-option">
              <input type="checkbox" id="filterEwsWeather" checked>
              <span>Orion WeatherHub (cuaca)</span>
            </label>
            <label class="filter-option">
              <input type="checkbox" id="filterLakes">
              <span>Waduk / danau / kolam</span>
            </label>
            <label class="filter-option">
              <input type="checkbox" id="filterIrrigation">
              <span>Saluran irigasi / kanal</span>
            </label>
            <label class="filter-option">
              <input type="checkbox" id="filterAdminKabupaten">
              <span>Batas Kabupaten</span>
            </label>
            <label class="filter-option">
              <input type="checkbox" id="filterAdminKecamatan">
              <span>Batas Kecamatan</span>
            </label>
            <label class="filter-option">
              <input type="checkbox" id="filterVillages">
              <span>Batas Desa</span>
            </label>
            <label class="filter-option">
              <input type="checkbox" id="filterSettlements">
              <span>Sebaran Pemukiman</span>
            </label>
            <label class="filter-option">
              <input type="checkbox" id="filterContours">
              <span>Kontur tanah / elevasi</span>
            </label>
            <label class="filter-option">
              <input type="checkbox" id="filterLandslideRisk">
              <span>Zona kerentanan gerakan tanah</span>
            </label>
            <label class="filter-option">
              <input type="checkbox" id="filterNatural">
              <span>Area alami (hutan/taman)</span>
            </label>
            <label class="filter-option">
              <input type="checkbox" id="filterPlaces">
              <span>Nama desa</span>
            </label>
            <label class="filter-option">
              <input type="checkbox" id="filterPois">
              <span>Titik penting (fasilitas & simpang)</span>
            </label>
          </div>
        </div>
        <div>
          <div class="panel-section-title">Filter Bencana</div>
          <div class="filter-group">
            <div class="year-selector" style="margin-bottom: 12px; padding: 8px; border-radius: 6px; background: rgba(148, 163, 184, 0.1);">
              <div class="status-label" style="margin-bottom: 6px;">Tahun Data Bencana:</div>
              <select id="disasterYearSelect" style="width: 100%; padding: 6px; border-radius: 4px; border: 1px solid rgba(148, 163, 184, 0.3); background: rgba(15, 23, 42, 0.8); color: #e5e7eb;">
                <option value="2024">2024</option>
                <option value="2023">2023</option>
                <option value="2022">2022</option>
                <option value="2021">2021</option>
              </select>
            </div>
            <label class="filter-option">
              <input type="checkbox" id="filterKebakaran" value="Kebakaran">
              <span>Kebakaran</span>
            </label>
            <label class="filter-option">
              <input type="checkbox" id="filterLongsor" value="Tanah Longsor">
              <span>Tanah Longsor</span>
            </label>
            <label class="filter-option">
              <input type="checkbox" id="filterAngin" value="Angin kencang">
              <span>Angin Kencang</span>
            </label>
            <label class="filter-option">
              <input type="checkbox" id="filterPohon" value="Pohon Tumbang">
              <span>Pohon Tumbang</span>
            </label>
            <label class="filter-option">
              <input type="checkbox" id="filterOrangHilang" value="Orang Hilang">
              <span>Orang Hilang</span>
            </label>
            <label class="filter-option">
              <input type="checkbox" id="filterAllBencana" class="select-all">
              <span>Pilih Semua Bencana</span>
            </label>
          </div>
        </div>

        <div>
          <div class="panel-section-title">Legenda Proyeksi Iklim BMKG</div>
          <div class="status-box">
            <div class="status-label">Perubahan curah hujan musiman</div>
            <div id="climateLegendContainer" class="status-text"></div>
          </div>
        </div>
        <div>
          <div class="panel-section-title">Status Data Peta</div>
          <div class="status-box half-width">
            <div class="status-label">Kondisi permintaan data</div>
            <div id="statusText" class="status-text">Lokasi EWS telah dimuat dari database.</div>
            <button id="exportButton" class="export-button half-width">
              <span class="export-icon"></span>
              <span>Unduh GeoJSON Banjarnegara</span>
            </button>
          </div>
        </div>
        <div>
          <div class="panel-section-title">Data Lokal</div>
          <div class="status-box half-width">
            <div class="status-label">Muat berkas GeoJSON pendukung</div>
            <input type="file" id="geojsonFileInput" accept=".geojson,application/geo+json,application/json" style="display: none;">
            <button id="loadLocalGeojsonButton" class="export-button half-width">
              <span class="export-icon"></span>
              <span>Muat GeoJSON lokal</span>
            </button>
            <div class="orion-link-small">
              <a href="orion.html" target="_blank" rel="noopener noreferrer">Buka Orion Overview</a>
            </div>
            <div class="orion-link-small">
              <a href="marker-editor.html" target="_blank" rel="noopener noreferrer">ðŸ“Œ Editor Marker Geosiana</a>
            </div>
          </div>
        </div>
        <div class="footer-note">
          Sumber ubin peta: <a href="https://www.openstreetmap.org" target="_blank" rel="noopener noreferrer">OpenStreetMap</a>.
          Data geometri air permukaan diambil melalui Overpass API berbasis OpenStreetMap.
        </div>
      </aside>
    </div>
  </div>

  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>
  <script>
    var map;
    var baseLayerOsm;
    var baseLayerSatellite;
    var baseLayerTopo;
    var waterLayer;
    var statusText = document.getElementById("statusText");
    var mapLoadingOverlay = document.getElementById("mapLoadingOverlay");
    var refreshButton = document.getElementById("refreshButton");
    var filterRiversCheckbox = document.getElementById("filterRivers");
    var filterLocalRiversCheckbox = document.getElementById("filterLocalRivers");
    var filterRoadsCheckbox = document.getElementById("filterRoads");
    var filterRoadSectionsCheckbox = document.getElementById("filterRoadSections");
    var filterRainCheckbox = document.getElementById("filterRain");
    var filterClimateDJFCheckbox = document.getElementById("filterClimateDJF");
    var filterClimateMAMCheckbox = document.getElementById("filterClimateMAM");
    var filterClimateJJACheckbox = document.getElementById("filterClimateJJA");
    var filterClimateSONCheckbox = document.getElementById("filterClimateSON");
    var filterQuakesCheckbox = document.getElementById("filterQuakes");
    var filterSeismicJateng2021Checkbox = document.getElementById("filterSeismicJateng2021");
    var filterGroundwaterCheckbox = document.getElementById("filterGroundwater");
    var filterSoilCheckbox = document.getElementById("filterSoil");
    var filterEwsCheckbox = document.getElementById("filterEws");
    var filterEwsFloodCheckbox = document.getElementById("filterEwsFlood");
    var filterEwsGeoCheckbox = document.getElementById("filterEwsGeo");
    var filterEwsQuakeTypeCheckbox = document.getElementById("filterEwsQuake");
    var filterEwsMagmaCheckbox = document.getElementById("filterEwsMagma");
    var filterEwsWeatherCheckbox = document.getElementById("filterEwsWeather");
    var filterLakesCheckbox = document.getElementById("filterLakes");
    var filterIrrigationCheckbox = document.getElementById("filterIrrigation");
    var filterVillagesCheckbox = document.getElementById("filterVillages");
    var filterBuildingsCheckbox = document.getElementById("filterBuildings");
    var filterContoursCheckbox = document.getElementById("filterContours");
    var filterLandslideRiskCheckbox = document.getElementById("filterLandslideRisk");
    var filterNaturalCheckbox = document.getElementById("filterNatural");
    var filterPlacesCheckbox = document.getElementById("filterPlaces");
    var filterPoisCheckbox = document.getElementById("filterPois");
    var filterKebakaranCheckbox = document.getElementById("filterKebakaran");
    var filterLongsorCheckbox = document.getElementById("filterLongsor");
    var filterAnginCheckbox = document.getElementById("filterAngin");
    var filterPohonCheckbox = document.getElementById("filterPohon");
    var filterOrangHilangCheckbox = document.getElementById("filterOrangHilang");
    var filterAllBencanaCheckbox = document.getElementById("filterAllBencana");
    
    console.log('Disaster checkboxes found:');
    console.log('Kebakaran:', !!filterKebakaranCheckbox);
    console.log('Longsor:', !!filterLongsorCheckbox);
    console.log('Angin:', !!filterAnginCheckbox);
    console.log('Pilih Semua:', !!filterAllBencanaCheckbox);
    var exportButton = document.getElementById("exportButton");
    var geojsonFileInput = document.getElementById("geojsonFileInput");
    var loadLocalGeojsonButton = document.getElementById("loadLocalGeojsonButton");

    var waterRiversLayer;
    var localRiversLayer;
    var roadsLayer;
    var roadSectionsLayer;
    var waterLakesLayer;
    var waterIrrigationLayer;
    var villageLayer;
    var buildingsLayer;
    var contourLayer;
    var rainLayer;
    var climateDJFLayer;
    var climateMAMLayer;
    var climateJJALayer;
    var climateSONLayer;
    var quakesLayer;
    var seismicJateng2021Layer;
    var groundwaterLayer;
    var soilLayer;
    var ewsLayer;
    var ewsData = null;
    var villageAlertLookup = {};
    var villageRiskLookup = {};
    var naturalLayer;
    var placesLayer;
    var poisLayer;
    var landslideRiskLayer;
    var lastGeoJson = null;
    var landslideRiskGeojson = null;
    var soilGeojsonData = null;
    var contourGeojsonData = null;
    var localRiversGeojsonData = null;
    var rainForecastCache = {};
    var floodForecastCache = {};
    var globalRainForecastData = null;
    var globalRainForecastError = null;
    var globalRainForecastLoading = false;
    var globalRainForecastRequestedAt = null;
    var globalRainForecastMaxWaitMs = 15000;
    var bmkgNowcastContainer = document.getElementById("bmkgNowcastContainer");
    var bmkgNowcastInfo = null;
    var bmkgAlertKecamatanLookup = {};
    var ewsIconFlood;
    var ewsIconGeo;
    var ewsIconQuake;
    var ewsIconMagma;
    var ewsIconWeather;
    var ewsIconUnknown;
    var overpassEndpoints = [
      "https://overpass-api.de/api/interpreter",
      "https://overpass.kumi.systems/api/interpreter",
      "https://overpass.openstreetmap.fr/api/interpreter"
    ];

    function normalizeVillageName(name) {
      if (!name) {
        return "";
      }
      return String(name)
        .toLowerCase()
        .replace(/\s+/g, " ")
        .trim();
    }

    function pointInPolygon(point, polygonCoords) {
      var x = point[0];
      var y = point[1];
      var inside = false;
      for (var i = 0, j = polygonCoords.length - 1; i < polygonCoords.length; j = i++) {
        var xi = polygonCoords[i][0];
        var yi = polygonCoords[i][1];
        var xj = polygonCoords[j][0];
        var yj = polygonCoords[j][1];
        var intersect =
          yi > y !== yj > y &&
          x < ((xj - xi) * (y - yi)) / (yj - yi + 0.0000001) + xi;
        if (intersect) {
          inside = !inside;
        }
      }
      return inside;
    }

    function getFeatureCentroid(feature) {
      if (!feature || !feature.geometry) {
        return null;
      }
      var geom = feature.geometry;
      if (geom.type === "Point") {
        return {
          lng: geom.coordinates[0],
          lat: geom.coordinates[1]
        };
      }
      if (geom.type === "Polygon") {
        var ring = geom.coordinates[0] || [];
        if (!ring.length) {
          return null;
        }
        var sumX = 0;
        var sumY = 0;
        for (var i = 0; i < ring.length; i++) {
          sumX += ring[i][0];
          sumY += ring[i][1];
        }
        return {
          lng: sumX / ring.length,
          lat: sumY / ring.length
        };
      }
      if (geom.type === "MultiPolygon") {
        if (!geom.coordinates.length || !geom.coordinates[0].length) {
          return null;
        }
        var firstRing = geom.coordinates[0][0] || [];
        if (!firstRing.length) {
          return null;
        }
        var sx = 0;
        var sy = 0;
        for (var k = 0; k < firstRing.length; k++) {
          sx += firstRing[k][0];
          sy += firstRing[k][1];
        }
        return {
          lng: sx / firstRing.length,
          lat: sy / firstRing.length
        };
      }
      return null;
    }

    function distanceMeters(lng1, lat1, lng2, lat2) {
      var rad = Math.PI / 180;
      var x = (lng2 - lng1) * Math.cos(((lat1 + lat2) / 2) * rad);
      var y = lat2 - lat1;
      return Math.sqrt(x * x + y * y) * 111320;
    }

    function distancePointToLineStringMeters(lng, lat, coords) {
      if (!coords || coords.length < 2) {
        return Infinity;
      }
      var minDist = Infinity;
      for (var i = 0; i < coords.length - 1; i++) {
        var p1 = coords[i];
        var p2 = coords[i + 1];
        var x1 = p1[0];
        var y1 = p1[1];
        var x2 = p2[0];
        var y2 = p2[1];
        var dx = x2 - x1;
        var dy = y2 - y1;
        var len2 = dx * dx + dy * dy;
        var t = 0;
        if (len2 > 0) {
          t = ((lng - x1) * dx + (lat - y1) * dy) / len2;
          if (t < 0) {
            t = 0;
          } else if (t > 1) {
            t = 1;
          }
        }
        var projX = x1 + t * dx;
        var projY = y1 + t * dy;
        var d = distanceMeters(lng, lat, projX, projY);
        if (d < minDist) {
          minDist = d;
        }
      }
      return minDist;
    }

    function tryComputeVillageRisk() {
      if (!villageLayer || !landslideRiskGeojson || !soilGeojsonData) {
        return;
      }
      computeVillageRiskScores();
    }

    function getLandslideRiskAt(lat, lng) {
      if (!landslideRiskGeojson || !landslideRiskGeojson.features) {
        return "unknown";
      }
      var point = [lng, lat];
      for (var i = 0; i < landslideRiskGeojson.features.length; i++) {
        var f = landslideRiskGeojson.features[i];
        if (!f.geometry || !f.geometry.coordinates) {
          continue;
        }
        var geom = f.geometry;
        if (geom.type === "Polygon") {
          if (pointInPolygon(point, geom.coordinates[0] || [])) {
            return getLandslideRiskCategory(f.properties);
          }
        } else if (geom.type === "MultiPolygon") {
          var polys = geom.coordinates;
          for (var j = 0; j < polys.length; j++) {
            if (pointInPolygon(point, polys[j][0] || [])) {
              return getLandslideRiskCategory(f.properties);
            }
          }
        }
      }
      return "unknown";
    }

    function classifySoilName(name) {
      if (!name) {
        return "unknown";
      }
      var text = String(name).toLowerCase();
      if (text.indexOf("regosol") !== -1) {
        return "regosol";
      }
      if (text.indexOf("litosol") !== -1) {
        return "litosol";
      }
      if (text.indexOf("mediteran") !== -1) {
        return "mediteran";
      }
      if (text.indexOf("aluvial") !== -1 || text.indexOf("alluvial") !== -1) {
        return "aluvial";
      }
      if (text.indexOf("andosol") !== -1) {
        return "andosol";
      }
      return "other";
    }

    function getSoilAt(lat, lng) {
      if (!soilGeojsonData || !soilGeojsonData.features) {
        return {
          macam: null,
          cls: "unknown"
        };
      }
      var point = [lng, lat];
      for (var i = 0; i < soilGeojsonData.features.length; i++) {
        var f = soilGeojsonData.features[i];
        if (!f.geometry || !f.geometry.coordinates) {
          continue;
        }
        var geom = f.geometry;
        if (geom.type === "Polygon") {
          if (pointInPolygon(point, geom.coordinates[0] || [])) {
            var macam = f.properties && f.properties.MACAM_TANA ? f.properties.MACAM_TANA : null;
            return {
              macam: macam,
              cls: classifySoilName(macam)
            };
          }
        } else if (geom.type === "MultiPolygon") {
          var polys = geom.coordinates;
          for (var j = 0; j < polys.length; j++) {
            if (pointInPolygon(point, polys[j][0] || [])) {
              var macam2 =
                f.properties && f.properties.MACAM_TANA ? f.properties.MACAM_TANA : null;
              return {
                macam: macam2,
                cls: classifySoilName(macam2)
              };
            }
          }
        }
      }
      return {
        macam: null,
        cls: "unknown"
      };
    }

    function getSlopeClassAt(lat, lng) {
      if (!contourGeojsonData || !contourGeojsonData.features) {
        return {
          cls: "unknown",
          score: 0
        };
      }
      var minH = null;
      var maxH = null;
      for (var i = 0; i < contourGeojsonData.features.length; i++) {
        var f = contourGeojsonData.features[i];
        var props = f && f.properties ? f.properties : {};
        var h = typeof props.HEIGHT === "number" ? props.HEIGHT : null;
        if (h === null) {
          continue;
        }
        if (!f.geometry || !f.geometry.coordinates) {
          continue;
        }
        var geom = f.geometry;
        var coords = [];
        if (geom.type === "LineString") {
          coords = geom.coordinates;
        } else if (geom.type === "MultiLineString") {
          coords = geom.coordinates[0] || [];
        }
        if (!coords.length) {
          continue;
        }
        var dist = distancePointToLineStringMeters(lng, lat, coords);
        if (dist > 1500) {
          continue;
        }
        if (minH === null || h < minH) {
          minH = h;
        }
        if (maxH === null || h > maxH) {
          maxH = h;
        }
      }
      if (minH === null || maxH === null) {
        return {
          cls: "unknown",
          score: 0
        };
      }
      var delta = maxH - minH;
      if (delta > 200) {
        return {
          cls: "curam",
          score: 2
        };
      }
      if (delta > 100) {
        return {
          cls: "sedang",
          score: 1
        };
      }
      return {
        cls: "landai",
        score: 0
      };
    }

    function getRiverDistanceInfo(lat, lng) {
      if (!localRiversGeojsonData || !localRiversGeojsonData.features) {
        return {
          distance: null,
          score: 0
        };
      }
      var minDist = null;
      for (var i = 0; i < localRiversGeojsonData.features.length; i++) {
        var f = localRiversGeojsonData.features[i];
        if (!f.geometry || !f.geometry.coordinates) {
          continue;
        }
        var geom = f.geometry;
        var coords = [];
        if (geom.type === "LineString") {
          coords = geom.coordinates;
        } else if (geom.type === "MultiLineString") {
          coords = geom.coordinates[0] || [];
        }
        if (!coords.length) {
          continue;
        }
        var d = distancePointToLineStringMeters(lng, lat, coords);
        if (minDist === null || d < minDist) {
          minDist = d;
        }
      }
      if (minDist === null) {
        return {
          distance: null,
          score: 0
        };
      }
      var score = 0;
      if (minDist < 250) {
        score = 2;
      } else if (minDist < 500) {
        score = 1;
      }
      return {
        distance: minDist,
        score: score
      };
    }

    function computeVillageRiskScores() {
      if (!villageLayer || !landslideRiskGeojson || !soilGeojsonData) {
        return;
      }
      villageRiskLookup = {};
      villageLayer.eachLayer(function (layer) {
        var feature = layer.feature;
        if (!feature || !feature.geometry) {
          return;
        }
        var centroid = getFeatureCentroid(feature);
        if (!centroid) {
          return;
        }
        var lat = centroid.lat;
        var lng = centroid.lng;
        var props = feature.properties || {};
        var name =
          props.Nama_Desa_ ||
          props.NAMOBJ ||
          props.name ||
          props.Desa ||
          props.DESA ||
          "";
        var key = normalizeVillageName(name);
        if (!key) {
          return;
        }
        var zoneCat = getLandslideRiskAt(lat, lng);
        var zoneScore = 0;
        if (zoneCat === "aliran") {
          zoneScore = 4;
        } else if (zoneCat === "tinggi") {
          zoneScore = 3;
        } else if (zoneCat === "menengah") {
          zoneScore = 2;
        } else if (zoneCat === "rendah") {
          zoneScore = 1;
        } else if (zoneCat === "sangat_rendah") {
          zoneScore = 0;
        }
        var soilInfo = getSoilAt(lat, lng);
        var soilScore = 0;
        if (soilInfo.cls === "regosol" || soilInfo.cls === "litosol") {
          soilScore = 2;
        } else if (soilInfo.cls === "mediteran") {
          soilScore = 1;
        } else if (soilInfo.cls === "aluvial") {
          soilScore = 1;
        } else {
          soilScore = 0;
        }
        var slopeInfo = getSlopeClassAt(lat, lng);
        var riverInfo = getRiverDistanceInfo(lat, lng);
        var totalScore = zoneScore + soilScore + slopeInfo.score + riverInfo.score;
        var level = "rendah";
        if (totalScore >= 9) {
          level = "sangat_tinggi";
        } else if (totalScore >= 6) {
          level = "tinggi";
        } else if (totalScore >= 3) {
          level = "sedang";
        }
        villageRiskLookup[key] = {
          score: totalScore,
          level: level,
          zone: zoneCat,
          soilClass: soilInfo.cls,
          soilName: soilInfo.macam,
          slopeClass: slopeInfo.cls,
          riverDistance: riverInfo.distance,
          factors: {
            zone: zoneScore,
            soil: soilScore,
            slope: slopeInfo.score,
            river: riverInfo.score
          }
        };
      });
      if (villageLayer) {
        villageLayer.setStyle(styleVillageFeature);
      }
    }

    var banjarnegaraCenter = {
      lat: -7.45,
      lng: 109.68
    };

    var banjarnegaraBBox = {
      south: -7.6,
      west: 109.5,
      north: -7.25,
      east: 109.9
    };

    function buildBmkgNowcastUrl() {
      return "https://www.bmkg.go.id/alerts/nowcast/id";
    }

    function buildRainForecastUrl(lat, lng) {
      var base = "https://api.open-meteo.com/v1/forecast";
      var params = new URLSearchParams();
      params.append("latitude", String(lat));
      params.append("longitude", String(lng));
      params.append("hourly", "rain,showers,cloud_cover,evapotranspiration");
      params.append("timezone", "Asia/Bangkok");
      params.append("forecast_days", "3");
      return base + "?" + params.toString();
    }

    function fetchRainForecast(lat, lng) {
      var key = lat.toFixed(3) + "," + lng.toFixed(3);
      if (rainForecastCache[key]) {
        return rainForecastCache[key];
      }
      var url = buildRainForecastUrl(lat, lng);
      var p = fetch(url)
        .then(function (response) {
          if (!response.ok) {
            throw new Error("HTTP " + response.status + " dari API hujan");
          }
          return response.json();
        })
        .catch(function () {
          return null;
        });
      rainForecastCache[key] = p;
      return p;
    }

    function buildFloodForecastUrl(lat, lng) {
      var base = "https://flood-api.open-meteo.com/v1/flood";
      var params = new URLSearchParams();
      params.append("latitude", String(lat));
      params.append("longitude", String(lng));
      params.append("daily", "river_discharge,river_discharge_mean");
      params.append("timezone", "Asia/Bangkok");
      return base + "?" + params.toString();
    }

    function fetchFloodForecast(lat, lng) {
      var key = lat.toFixed(3) + "," + lng.toFixed(3);
      if (floodForecastCache[key]) {
        return floodForecastCache[key];
      }
      var url = buildFloodForecastUrl(lat, lng);
      var p = fetch(url)
        .then(function (response) {
          if (!response.ok) {
            throw new Error("HTTP " + response.status + " dari API flood");
          }
          return response.json();
        })
        .catch(function () {
          return null;
        });
      floodForecastCache[key] = p;
      return p;
    }

    function buildRainForecastUrl(lat, lng) {
      var base = "https://api.open-meteo.com/v1/forecast";
      var params = new URLSearchParams();
      params.append("latitude", String(lat));
      params.append("longitude", String(lng));
      params.append("hourly", "rain,showers,cloud_cover,evapotranspiration");
      params.append("timezone", "Asia/Bangkok");
      params.append("forecast_days", "3");
      return base + "?" + params.toString();
    }

    function fetchRainForecast(lat, lng) {
      var key = lat.toFixed(3) + "," + lng.toFixed(3);
      if (rainForecastCache[key]) {
        return rainForecastCache[key];
      }
      var url = buildRainForecastUrl(lat, lng);
      var p = fetch(url)
        .then(function (response) {
          if (!response.ok) {
            throw new Error("HTTP " + response.status + " dari API hujan");
          }
          return response.json();
        })
        .catch(function () {
          return null;
        });
      rainForecastCache[key] = p;
      return p;
    }

    function summarizeRainLabel(totalMm) {
      if (totalMm === null || typeof totalMm === "undefined") {
        return null;
      }
      if (totalMm < 2) {
        return "ringan";
      }
      if (totalMm < 10) {
        return "sedang";
      }
      return "lebat";
    }

    function summarizeFloodToday(data) {
      if (
        !data ||
        !data.daily ||
        !data.daily.river_discharge ||
        !data.daily.river_discharge_mean ||
        !data.daily.river_discharge.length ||
        !data.daily.river_discharge_mean.length
      ) {
        return null;
      }
      var discharge = data.daily.river_discharge[0];
      var mean = data.daily.river_discharge_mean[0];
      if (typeof discharge !== "number" || typeof mean !== "number" || mean <= 0) {
        return null;
      }
      var ratio = discharge / mean;
      var label = "";
      if (ratio < 0.8) {
        label = "di bawah normal";
      } else if (ratio < 1.2) {
        label = "sekitar normal";
      } else if (ratio < 1.5) {
        label = "di atas normal";
      } else {
        label = "sangat tinggi (potensi banjir)";
      }
      return {
        discharge: discharge,
        mean: mean,
        ratio: ratio,
        label: label
      };
    }

    function summarizeFloodNext3Days(data) {
      if (
        !data ||
        !data.daily ||
        !data.daily.river_discharge ||
        !data.daily.river_discharge_mean ||
        !data.daily.river_discharge.length ||
        !data.daily.river_discharge_mean.length
      ) {
        return null;
      }
      var maxDischarge = null;
      var maxMean = null;
      var maxRatio = null;
      var days = Math.min(3, data.daily.river_discharge.length);
      for (var i = 0; i < days; i++) {
        var d = data.daily.river_discharge[i];
        var m = data.daily.river_discharge_mean[i];
        if (typeof d !== "number" || typeof m !== "number" || m <= 0) {
          continue;
        }
        if (maxDischarge === null || d > maxDischarge) {
          maxDischarge = d;
          maxMean = m;
          maxRatio = d / m;
        }
      }
      if (maxDischarge === null || maxMean === null || maxRatio === null) {
        return null;
      }
      var label = "";
      if (maxRatio < 0.8) {
        label = "di bawah normal";
      } else if (maxRatio < 1.2) {
        label = "sekitar normal";
      } else if (maxRatio < 1.5) {
        label = "di atas normal";
      } else {
        label = "sangat tinggi (potensi banjir)";
      }
      return {
        maxDischarge: maxDischarge,
        mean: maxMean,
        ratio: maxRatio,
        label: label
      };
    }

    function summarizeNextHoursRain(data, hoursAhead) {
      if (!data || !data.hourly || !data.hourly.time || !data.hourly.rain || !data.hourly.showers) {
        return null;
      }
      var times = data.hourly.time;
      var rain = data.hourly.rain;
      var showers = data.hourly.showers;
      var now = new Date();
      var until = new Date(now.getTime() + hoursAhead * 60 * 60 * 1000);
      var total = 0;
      for (var i = 0; i < times.length; i++) {
        var t = new Date(times[i]);
        if (t > until) {
          break;
        }
        if (t >= now && t <= until) {
          var r = typeof rain[i] === "number" ? rain[i] : 0;
          var s = typeof showers[i] === "number" ? showers[i] : 0;
          total += r + s;
        }
      }
      var label = summarizeRainLabel(total);
      return {
        total: total,
        label: label
      };
    }

    function summarizeNext24HoursRain(data) {
      return summarizeNextHoursRain(data, 24);
    }

    function ensureGlobalRainForecast() {
      if (globalRainForecastData || globalRainForecastLoading || globalRainForecastError) {
        return;
      }
      globalRainForecastLoading = true;
      globalRainForecastRequestedAt = Date.now();
      fetchRainForecast(banjarnegaraCenter.lat, banjarnegaraCenter.lng)
        .then(function (data) {
          globalRainForecastLoading = false;
          if (data) {
            globalRainForecastData = data;
          } else {
            globalRainForecastError = true;
          }
        })
        .catch(function () {
          globalRainForecastLoading = false;
          globalRainForecastError = true;
        });
    }

    function getGlobalVillageRainSummaryText() {
      ensureGlobalRainForecast();
      if (globalRainForecastData) {
        var summary = summarizeNext24HoursRain(globalRainForecastData);
        if (summary && typeof summary.total === "number") {
          var label = summary.label || "";
          var text = "Hujan 24 jam ke depan: " + summary.total.toFixed(1) + " mm";
          if (label) {
            text += " (" + label + ")";
          }
          return text;
        }
      }
      if (globalRainForecastLoading) {
        if (globalRainForecastRequestedAt) {
          var elapsed = Date.now() - globalRainForecastRequestedAt;
          if (elapsed > globalRainForecastMaxWaitMs) {
            globalRainForecastLoading = false;
            globalRainForecastError = true;
            return "Hujan 24 jam ke depan: tidak tersedia";
          }
        }
        return "Hujan 24 jam ke depan: memuatâ€¦";
      }
      if (globalRainForecastError) {
        return "Hujan 24 jam ke depan: tidak tersedia";
      }
      return null;
    }

    function filterBmkgDescriptionForBanjarnegara(text) {
      if (!text) {
        return "";
      }
      var parts = text.split(/[\r\n]+|(?<=\.)\s+/);
      var kept = [];
      for (var i = 0; i < parts.length; i++) {
        var p = parts[i].trim();
        if (!p) {
          continue;
        }
        var lower = p.toLowerCase();
        if (lower.indexOf("banjarnegara") !== -1) {
          kept.push(p);
        }
      }
      if (!kept.length) {
        return text;
      }
      return kept.join(" ");
    }

    function applyBmkgNowcastHighlight() {
      if (!bmkgNowcastInfo || !bmkgNowcastInfo.description || !villageLayer) {
        return;
      }
      bmkgAlertKecamatanLookup = {};
      var desc = String(bmkgNowcastInfo.description);
      var descLower = desc.toLowerCase();
      villageLayer.eachLayer(function (layer) {
        var feature = layer.feature;
        if (!feature || !feature.properties) {
          return;
        }
        var props = feature.properties;
        var kecamatan = props.Kecamatan || props.KECAMATAN || "";
        var kabupaten = props.Kabupaten || props.KABUPATEN || "";
        if (!kecamatan) {
          return;
        }
        if (!kabupaten || kabupaten.toLowerCase().indexOf("banjarnegara") === -1) {
          return;
        }
        var kecLower = String(kecamatan).toLowerCase();
        if (
          descLower.indexOf(kecLower) === -1 &&
          descLower.indexOf("kec. " + kecLower) === -1 &&
          descLower.indexOf("kecamatan " + kecLower) === -1
        ) {
          return;
        }
        var kecKey = normalizeVillageName(kecamatan);
        if (!kecKey) {
          return;
        }
        bmkgAlertKecamatanLookup[kecKey] = true;
      });
      if (villageLayer) {
        villageLayer.setStyle(styleVillageFeature);
      }
    }

    function fetchBmkgNowcastForProvince(callback) {
      if (!bmkgNowcastContainer) {
        return;
      }
      bmkgNowcastContainer.textContent = "Memuat peringatan dini cuaca BMKGâ€¦";
      var url = buildBmkgNowcastUrl();
      
      // Skip BMKG API call on localhost to avoid CORS errors
      console.warn("Skipping BMKG API call on localhost to avoid CORS errors");
      bmkgNowcastContainer.textContent = "Info BMKG tidak tersedia di localhost (CORS).";
      if (callback) {
        callback(null);
      }
      return;
    }

    function setStatus(text, type) {
      statusText.textContent = text;
      statusText.classList.remove("ok", "loading", "error");
      if (type) {
        statusText.classList.add(type);
      }
    }

    function toggleLoading(isLoading) {
      mapLoadingOverlay.style.display = isLoading ? "flex" : "none";
      refreshButton.disabled = isLoading;
      if (isLoading) {
        setStatus("Mengambil data air permukaan dari Overpass APIâ€¦", "loading");
      } else {
        setStatus("Data air permukaan telah dimuat.", "ok");
      }
    }

    function buildOverpassQuery(bbox) {
      var b = bbox.south + "," + bbox.west + "," + bbox.north + "," + bbox.east;
      var query = [
        "[out:json][timeout:80];",
        "(",
        "  way[\"water\"](" + b + ");",
        "  way[\"waterway\"](" + b + ");",
        "  relation[\"water\"](" + b + ");",
        "  relation[\"waterway\"](" + b + ");",
        ");",
        "out body;",
        ">;",
        "out skel qt;"
      ].join("\n");
      return query;
    }

    function overpassToGeoJSON(data) {
      var elements = data && data.elements ? data.elements : [];
      var nodesById = {};
      var features = [];

      for (var i = 0; i < elements.length; i++) {
        var el = elements[i];
        if (el.type === "node" && typeof el.id !== "undefined") {
          nodesById[el.id] = [el.lon, el.lat];
        }
      }

      function buildCoordinates(nodeIds) {
        var coords = [];
        for (var j = 0; j < nodeIds.length; j++) {
          var pt = nodesById[nodeIds[j]];
          if (pt) {
            coords.push(pt);
          }
        }
        return coords;
      }

      for (var k = 0; k < elements.length; k++) {
        var way = elements[k];
        if (way.type !== "way" || !Array.isArray(way.nodes)) {
          continue;
        }

        var coords = buildCoordinates(way.nodes);
        if (coords.length < 2) {
          continue;
        }

        var first = coords[0];
        var last = coords[coords.length - 1];
        var isClosed = first[0] === last[0] && first[1] === last[1] && coords.length >= 4;

        var geometry;
        if (isClosed) {
          geometry = {
            type: "Polygon",
            coordinates: [coords]
          };
        } else {
          geometry = {
            type: "LineString",
            coordinates: coords
          };
        }

        features.push({
          type: "Feature",
          geometry: geometry,
          properties: {
            id: way.id,
            tags: way.tags || {}
          }
        });
      }

      return {
        type: "FeatureCollection",
        features: features
      };
    }

    function loadGeoJSONObject(geojson, sourceLabel) {
      clearWaterLayers();
      lastGeoJson = geojson;
      createWaterLayers(geojson);
      setStatus("Data air permukaan dari " + sourceLabel + " telah dimuat.", "ok");
    }

    function getFeatureCategory(tags) {
      var waterway = tags.waterway || "";
      var water = tags.water || "";
      var landuse = tags.landuse || "";
      var natural = tags.natural || "";

      if (waterway === "river") {
        return "river";
      }

      if (
        water === "reservoir" ||
        water === "lake" ||
        water === "pond" ||
        landuse === "reservoir" ||
        natural === "water"
      ) {
        return "lake";
      }

      if (
        waterway === "canal" ||
        waterway === "drain" ||
        waterway === "ditch" ||
        waterway === "stream"
      ) {
        return "irrigation";
      }

      return "other";
    }

    function styleForFeature(feature) {
      var tags = feature && feature.properties && feature.properties.tags ? feature.properties.tags : {};
      var isArea = feature.geometry && feature.geometry.type && feature.geometry.type.indexOf("Polygon") !== -1;

      if (tags.water === "reservoir" || tags.landuse === "reservoir") {
        return {
          color: "#38bdf8",
          weight: 1.2,
          opacity: 0.95,
          fillColor: "#0ea5e9",
          fillOpacity: 0.35
        };
      }

      if (isArea || getFeatureCategory(tags) === "lake") {
        return {
          color: "#38bdf8",
          weight: 1,
          opacity: 0.9,
          fillColor: "#38bdf8",
          fillOpacity: 0.3
        };
      }

      return {
        color: "#22d3ee",
        weight: 2.2,
        opacity: 0.95
      };
    }

    function styleVillageFeature(feature) {
      var props = feature && feature.properties ? feature.properties : {};
      var name =
        props.Nama_Desa_ ||
        props.NAMOBJ ||
        props.name ||
        props.Desa ||
        props.DESA ||
        "";
      var key = normalizeVillageName(name);
      var isAlert = key && villageAlertLookup && villageAlertLookup[key];
      var riskInfo = key && villageRiskLookup ? villageRiskLookup[key] : null;
      var kecamatan = props.Kecamatan || props.KECAMATAN || "";
      var kecKey = kecamatan ? normalizeVillageName(kecamatan) : "";
      var hasBmkgAlert = kecKey && bmkgAlertKecamatanLookup && bmkgAlertKecamatanLookup[kecKey];

      var stroke = "#f97316";
      var fill = "#0b1120";
      var fillOpacity = 0.04;
      var weight = 1.2;

      if (isAlert) {
        stroke = "#ef4444";
        fill = "rgba(239, 68, 68, 0.45)";
        fillOpacity = 0.55;
        weight = 1.6;
      } else if (riskInfo) {
        if (riskInfo.level === "sangat_tinggi") {
          stroke = "#b91c1c";
          fill = "rgba(248, 113, 113, 0.6)";
          fillOpacity = 0.6;
        } else if (riskInfo.level === "tinggi") {
          stroke = "#ea580c";
          fill = "rgba(249, 115, 22, 0.55)";
          fillOpacity = 0.55;
        } else if (riskInfo.level === "sedang") {
          stroke = "#eab308";
          fill = "rgba(250, 204, 21, 0.5)";
          fillOpacity = 0.5;
        } else if (riskInfo.level === "rendah") {
          stroke = "#22c55e";
          fill = "rgba(74, 222, 128, 0.45)";
          fillOpacity = 0.45;
        }
      }

      if (hasBmkgAlert && !isAlert) {
        stroke = "#38bdf8";
        weight = 2;
      }

      return {
        color: stroke,
        weight: weight,
        opacity: 0.9,
        fillColor: fill,
        fillOpacity: fillOpacity
      };
    }

    function onEachVillageFeature(feature, layer) {
      var props = feature && feature.properties ? feature.properties : {};
      var name =
        props.Nama_Desa_ ||
        props.NAMOBJ ||
        props.name ||
        props.Desa ||
        props.DESA ||
        "Desa tanpa nama";
      var kecamatan = props.Kecamatan || props.KECAMATAN || "";
      var kabupaten = props.Kabupaten || props.KABUPATEN || "";

      var html = "<strong>" + name + "</strong>";
      var detailParts = [];
      if (kecamatan) {
        detailParts.push("Kecamatan: " + kecamatan);
      }
      if (kabupaten) {
        detailParts.push("Kabupaten: " + kabupaten);
      }
      if (detailParts.length) {
        html += "<br><small>" + detailParts.join(" Â· ") + "</small>";
      }

      var centroid = getFeatureCentroid(feature);
      if (centroid) {
        var zoneLabel = "Belum tersedia (layer belum aktif atau desa di luar cakupan data)";
        if (landslideRiskGeojson && landslideRiskGeojson.features) {
          var zoneCat = getLandslideRiskAt(centroid.lat, centroid.lng);
          if (zoneCat && zoneCat !== "unknown") {
            zoneLabel = zoneCat.replace("_", " ");
          }
        }
        html += "<br><small>Zona kerentanan gerakan tanah (BIG): " + zoneLabel + "</small>";

        var soilLabel = "Belum tersedia (layer belum aktif atau desa di luar cakupan data)";
        if (soilGeojsonData && soilGeojsonData.features) {
          var soilInfo = getSoilAt(centroid.lat, centroid.lng);
          if (soilInfo && soilInfo.macam) {
            soilLabel = soilInfo.macam;
          }
        }
        html += "<br><small>Jenis tanah dominan: " + soilLabel + "</small>";
      }

      var rainText = getGlobalVillageRainSummaryText();
      if (rainText) {
        html += "<br><small>" + rainText + "</small>";
      }

      layer.bindPopup(html);
    }

    function onEachWaterFeature(feature, layer) {
      var tags = feature && feature.properties && feature.properties.tags ? feature.properties.tags : {};
      var name = tags.name || tags["name:id"] || "Tanpa nama";
      var category = getFeatureCategory(tags);
      var categoryLabel = "Air permukaan";

      if (category === "river") {
        categoryLabel = "Sungai utama";
      } else if (category === "lake") {
        categoryLabel = "Waduk / danau / kolam";
      } else if (category === "irrigation") {
        categoryLabel = "Saluran irigasi / kanal";
      }

      var tagParts = [];
      if (tags.waterway) {
        tagParts.push("waterway=" + tags.waterway);
      }
      if (tags.water) {
        tagParts.push("water=" + tags.water);
      }
      if (tags.landuse) {
        tagParts.push("landuse=" + tags.landuse);
      }
      if (!tagParts.length) {
        tagParts.push("tidak ada tag utama");
      }

      var popupHtml =
        "<strong>" + name + "</strong><br>" +
        "<span>Jenis: " + categoryLabel + "</span><br>" +
        "<small>Tag: " + tagParts.join(", ") + "</small>";

      layer.bindPopup(popupHtml);
    }

    function clearWaterLayers() {
      if (waterRiversLayer) {
        map.removeLayer(waterRiversLayer);
        waterRiversLayer = null;
      }
      if (waterLakesLayer) {
        map.removeLayer(waterLakesLayer);
        waterLakesLayer = null;
      }
      if (waterIrrigationLayer) {
        map.removeLayer(waterIrrigationLayer);
        waterIrrigationLayer = null;
      }
    }

    function createVillageLayer(geojson) {
      if (villageLayer) {
        map.removeLayer(villageLayer);
        villageLayer = null;
      }
      villageLayer = L.geoJSON(geojson, {
        style: styleVillageFeature,
        onEachFeature: onEachVillageFeature,
        pane: "villagePane"
      });
      updateLayerVisibility();
      tryComputeVillageRisk();
      applyBmkgNowcastHighlight();
    }

    function styleLocalRiverFeature(feature) {
      return {
        color: "#0ea5e9",
        weight: 2.4,
        opacity: 0.95
      };
    }

    function onEachLocalRiverFeature(feature, layer) {
      var props = feature && feature.properties ? feature.properties : {};
      var name = props.name || "Sungai tanpa nama";
      var type = props.type || "river";
      var html =
        "<strong>" + name + "</strong><br>" +
        "<small>Jenis: " + type + " (data lokal)</small>";
      layer.bindPopup(html);
    }

    function createLocalRiversLayer(geojson) {
      if (localRiversLayer) {
        map.removeLayer(localRiversLayer);
        localRiversLayer = null;
      }
      localRiversGeojsonData = geojson;
      localRiversLayer = L.geoJSON(geojson, {
        style: styleLocalRiverFeature,
        onEachFeature: onEachLocalRiverFeature
      });
      updateLayerVisibility();
      tryComputeVillageRisk();
    }

    function styleContourFeature(feature) {
      var props = feature && feature.properties ? feature.properties : {};
      var height = typeof props.HEIGHT === "number" ? props.HEIGHT : null;
      var color = "#9ca3af";
      if (height !== null) {
        if (height < 400) {
          color = "#22c55e";
        } else if (height < 800) {
          color = "#eab308";
        } else if (height < 1200) {
          color = "#f97316";
        } else {
          color = "#ef4444";
        }
      }
      var weight = height !== null && height % 100 === 0 ? 1.4 : 0.9;
      return {
        color: color,
        weight: weight,
        opacity: 0.8
      };
    }

    function onEachContourFeature(feature, layer) {
      var props = feature && feature.properties ? feature.properties : {};
      var height = props.HEIGHT;
      var keter = props.KETERANGAN || "";
      var html = "";
      if (typeof height === "number") {
        html += "<strong>Elevasi: " + height + " m</strong>";
      } else {
        html += "<strong>Kontur tanah</strong>";
      }
      if (keter) {
        html += "<br><small>" + keter + "</small>";
      }
      layer.bindPopup(html);
    }

    function createContourLayer(geojson) {
      if (contourLayer) {
        map.removeLayer(contourLayer);
        contourLayer = null;
      }
      contourGeojsonData = geojson;
      contourLayer = L.geoJSON(geojson, {
        style: styleContourFeature,
        onEachFeature: onEachContourFeature
      });
      updateLayerVisibility();
      tryComputeVillageRisk();
    }

    function styleSoilFeature(feature) {
      var props = feature && feature.properties ? feature.properties : {};
      var macam = props.MACAM_TANA ? String(props.MACAM_TANA).toLowerCase() : "";
      var fill = "#e5e7eb";
      var stroke = "#4b5563";
      if (macam.indexOf("aluvial") !== -1) {
        fill = "rgba(191, 219, 254, 0.7)";
        stroke = "#1d4ed8";
      } else if (macam.indexOf("regosol") !== -1) {
        fill = "rgba(254, 202, 202, 0.8)";
        stroke = "#b91c1c";
      } else if (macam.indexOf("mediteran") !== -1) {
        fill = "rgba(254, 249, 195, 0.85)";
        stroke = "#a16207";
      } else if (macam.indexOf("litosol") !== -1) {
        fill = "rgba(220, 252, 231, 0.85)";
        stroke = "#15803d";
      } else if (macam.indexOf("andosol") !== -1) {
        fill = "rgba(221, 214, 254, 0.85)";
        stroke = "#6d28d9";
      }
      return {
        color: stroke,
        weight: 0.8,
        opacity: 0.9,
        fillColor: fill,
        fillOpacity: 0.6
      };
    }

    function onEachSoilFeature(feature, layer) {
      var props = feature && feature.properties ? feature.properties : {};
      var macam = props.MACAM_TANA || "Jenis tanah tidak diketahui";
      var bahan = props.BAHAN_INDU || "";
      var fisio = props.FISIOGRAFI || "";
      var area = typeof props.SHAPE_Area === "number" ? props.SHAPE_Area : props.AREA;
      var html = "<strong>" + macam + "</strong>";
      if (bahan) {
        html += "<br><small>Bahan induk: " + bahan + "</small>";
      }
      if (fisio) {
        html += "<br><small>Fisiografi: " + fisio + "</small>";
      }
      if (typeof area === "number" && area > 0) {
        var km2 = area / 1000000;
        html += "<br><small>Perkiraan luas: " + km2.toFixed(2) + " kmÂ²</small>";
      }
      layer.bindPopup(html);
    }

    function createSoilLayer(geojson) {
      if (soilLayer) {
        map.removeLayer(soilLayer);
        soilLayer = null;
      }
      soilGeojsonData = geojson;
      soilLayer = L.geoJSON(geojson, {
        style: styleSoilFeature,
        onEachFeature: onEachSoilFeature,
        pane: "soilPane"
      });
      updateLayerVisibility();
      tryComputeVillageRisk();
    }

    function styleBuildingFeature(feature) {
      return {
        color: "#f97316",
        weight: 0.9,
        opacity: 0.9,
        fillColor: "#fb923c",
        fillOpacity: 0.25
      };
    }

    function onEachBuildingFeature(feature, layer) {
      var props = feature && feature.properties ? feature.properties : {};
      var name =
        props.name ||
        props.NAME ||
        props.building ||
        "Bangunan";
      var html = "<strong>" + name + "</strong><br><small>Layer bangunan (GeoJSON lokal)</small>";
      layer.bindPopup(html);
    }

    function createBuildingsLayer(geojson) {
      if (buildingsLayer) {
        map.removeLayer(buildingsLayer);
        buildingsLayer = null;
      }
      buildingsLayer = L.geoJSON(geojson, {
        style: styleBuildingFeature,
        onEachFeature: onEachBuildingFeature
      });
      updateLayerVisibility();
    }

    function styleRoadFeature(feature) {
      return {
        color: "#facc15",
        weight: 2.4,
        opacity: 0.95
      };
    }

    function onEachRoadFeature(feature, layer) {
      var props = feature && feature.properties ? feature.properties : {};
      var name =
        props.name ||
        props.NAME ||
        "Jalan";
      var ref = props.ref || "";
      var html = "<strong>" + name + "</strong>";
      if (ref) {
        html += "<br><small>Ref: " + ref + "</small>";
      }
      html += "<br><small>Layer jalan (GeoJSON lokal)</small>";
      layer.bindPopup(html);
    }

    function createRoadsLayer(geojson) {
      if (roadsLayer) {
        map.removeLayer(roadsLayer);
        roadsLayer = null;
      }
      roadsLayer = L.geoJSON(geojson, {
        style: styleRoadFeature,
        onEachFeature: onEachRoadFeature
      });
      updateLayerVisibility();
    }

    function normalizeSqlCoordinate(text) {
      if (text === null || typeof text === "undefined") {
        return null;
      }
      var cleaned = String(text)
        .replace(",", ".")
        .replace(/[^\d\.\-\+]/g, "");
      var value = parseFloat(cleaned);
      if (isNaN(value)) {
        return null;
      }
      return value;
    }

    function parseRuasJalanSql(text) {
      var features = [];
      if (!text) {
        return {
          type: "FeatureCollection",
          features: features
        };
      }
      var regex = /\('([^']*)','([^']*)','([^']*)','([^']*)','([^']*)','([^']*)'/g;
      var match;
      while ((match = regex.exec(text)) !== null) {
        var noreg = match[1];
        var ruasja = match[2];
        var latRaw = match[5];
        var lonRaw = match[6];
        var lat = normalizeSqlCoordinate(latRaw);
        var lon = normalizeSqlCoordinate(lonRaw);
        if (lat === null || lon === null) {
          continue;
        }
        features.push({
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: [lon, lat]
          },
          properties: {
            noreg: noreg,
            ruasja: ruasja
          }
        });
      }
      return {
        type: "FeatureCollection",
        features: features
      };
    }

    function styleRoadSectionFeature(feature) {
      return {
        radius: 3.2,
        color: "#0ea5e9",
        weight: 1.2,
        fillColor: "#38bdf8",
        fillOpacity: 0.9
      };
    }

    function onEachRoadSectionFeature(feature, layer) {
      var props = feature && feature.properties ? feature.properties : {};
      var ruas =
        props.ruasja ||
        "Ruas jalan";
      var noreg = props.noreg || "";
      var html = "<strong>" + ruas + "</strong>";
      if (noreg) {
        html += "<br><small>No ruas: " + noreg + "</small>";
      }
      html += "<br><small>Data titik rambu (ruas_jalan.sql)</small>";
      layer.bindPopup(html);
    }

    function createRoadSectionsLayer(geojson) {
      if (roadSectionsLayer) {
        map.removeLayer(roadSectionsLayer);
        roadSectionsLayer = null;
      }
      roadSectionsLayer = L.geoJSON(geojson, {
        pointToLayer: function (feature, latlng) {
          return L.circleMarker(latlng, styleRoadSectionFeature(feature));
        },
        onEachFeature: onEachRoadSectionFeature
      });
      updateLayerVisibility();
    }

    function getRainValue(props) {
      var keys = [
        "CRHHJN",
        "CH",
        "CH_HR",
        "CURAH_HUJAN",
        "CURAH",
        "curah_hujan",
        "ch",
        "nilai"
      ];
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (typeof props[key] !== "undefined" && props[key] !== null) {
          var value = parseFloat(props[key]);
          if (!isNaN(value)) {
            return value;
          }
        }
      }
      for (var name in props) {
        if (!Object.prototype.hasOwnProperty.call(props, name)) {
          continue;
        }
        var lower = String(name).toLowerCase();
        if (
          lower.indexOf("curah") !== -1 ||
          lower.indexOf("ch") !== -1 ||
          lower.indexOf("rain") !== -1
        ) {
          var v = parseFloat(props[name]);
          if (!isNaN(v)) {
            return v;
          }
        }
      }
      return null;
    }

    function getRainCategory(value) {
      if (value === null) {
        return null;
      }
      if (value <= 0) {
        return "none";
      }
      if (value < 1000) {
        return "low";
      }
      if (value < 2000) {
        return "moderate";
      }
      if (value < 3000) {
        return "high";
      }
      return "very-high";
    }

    function styleRainFeature(feature) {
      var props = feature && feature.properties ? feature.properties : {};
      var value = getRainValue(props);
      var category = getRainCategory(value);
      var fill = "rgba(15,23,42,0.1)";
      if (category === "low") {
        fill = "#bfdbfe";
      } else if (category === "moderate") {
        fill = "#86efac";
      } else if (category === "high") {
        fill = "#fcd34d";
      } else if (category === "very-high") {
        fill = "#f87171";
      } else if (category === "none") {
        fill = "#e5e7eb";
      }
      return {
        color: "#0f172a",
        weight: 0.8,
        opacity: 0.6,
        fillColor: fill,
        fillOpacity: 0.55
      };
    }

    function onEachRainFeature(feature, layer) {
      var props = feature && feature.properties ? feature.properties : {};
      var value = getRainValue(props);
      var category = getRainCategory(value);
      var title =
        props.NAMA ||
        props.NAME ||
        "Zona curah hujan";
      var parts = [];
      if (value !== null) {
        var label = "";
        if (category === "low") {
          label = "Curah hujan tahunan rendah";
        } else if (category === "moderate") {
          label = "Curah hujan tahunan sedang";
        } else if (category === "high") {
          label = "Curah hujan tahunan tinggi";
        } else if (category === "very-high") {
          label = "Curah hujan tahunan sangat tinggi";
        } else if (category === "none") {
          label = "Tidak hujan signifikan";
        }
        var bandText = props.CRHHJN || props.crhhjn || "";
        var text = bandText || (value.toFixed(0) + " mm/tahun");
        if (label) {
          text += " (" + label + ")";
        }
        parts.push(text);
      }
      for (var key in props) {
        if (!Object.prototype.hasOwnProperty.call(props, key)) {
          continue;
        }
        if (props[key] === null || typeof props[key] === "undefined") {
          continue;
        }
        parts.push(key + ": " + props[key]);
      }
      var html = "<strong>" + title + "</strong>";
      if (parts.length) {
        html += "<br><small>" + parts.join(" Â· ") + "</small>";
      }
      layer.bindPopup(html);
    }

    function createRainLayer(geojson) {
      if (rainLayer) {
        map.removeLayer(rainLayer);
        rainLayer = null;
      }
      rainLayer = L.geoJSON(geojson, {
        style: styleRainFeature,
        onEachFeature: onEachRainFeature
      });
      updateLayerVisibility();
    }

    function getLandslideRiskCategory(props) {
      var namobj = (props && props.namobj ? String(props.namobj) : "").toLowerCase();
      var remark = (props && props.remark ? String(props.remark) : "").toLowerCase();
      var zona = (props && props.zona ? String(props.zona) : "").toLowerCase();
      var text = namobj || remark || zona;
      if (!text) {
        return "unknown";
      }
      if (text.indexOf("aliran bahan rombakan") !== -1) {
        return "aliran";
      }
      if (text.indexOf("sangat rendah") !== -1) {
        return "sangat_rendah";
      }
      if (text.indexOf("rendah") !== -1) {
        return "rendah";
      }
      if (text.indexOf("menengah") !== -1) {
        return "menengah";
      }
      if (text.indexOf("tinggi") !== -1) {
        return "tinggi";
      }
      return "unknown";
    }

    function styleLandslideRiskFeature(feature) {
      var props = feature && feature.properties ? feature.properties : {};
      var category = getLandslideRiskCategory(props);
      var fill = "rgba(148, 163, 184, 0.4)";
      var stroke = "#64748b";
      if (category === "tinggi") {
        fill = "rgba(220, 38, 38, 0.65)";
        stroke = "#b91c1c";
      } else if (category === "menengah") {
        fill = "rgba(234, 88, 12, 0.6)";
        stroke = "#ea580c";
      } else if (category === "rendah") {
        fill = "rgba(234, 179, 8, 0.55)";
        stroke = "#eab308";
      } else if (category === "sangat_rendah") {
        fill = "rgba(34, 197, 94, 0.45)";
        stroke = "#22c55e";
      } else if (category === "aliran") {
        fill = "rgba(168, 85, 247, 0.6)";
        stroke = "#a855f7";
      }
      return {
        color: stroke,
        weight: 1,
        opacity: 0.9,
        fillColor: fill,
        fillOpacity: 0.5
      };
    }

    function onEachLandslideRiskFeature(feature, layer) {
      var props = feature && feature.properties ? feature.properties : {};
      var zona = props.zona || "";
      var namobj = props.namobj || "";
      var tahun = props.tahun || "";
      var remark = props.remark || "";
      var html = "<strong>Peta Zona Kerentanan Gerakan Tanah</strong>";
      if (zona) {
        html += "<br><small>Zona: " + zona + "</small>";
      }
      if (namobj) {
        html += "<br><small>Nama obyek: " + namobj + "</small>";
      }
      if (tahun) {
        html += "<br><small>Tahun: " + tahun + "</small>";
      }
      if (remark) {
        html += "<br><small>Keterangan: " + remark + "</small>";
      }
      layer.bindPopup(html);
    }

    function createLandslideRiskLayer(geojson) {
      if (landslideRiskLayer) {
        map.removeLayer(landslideRiskLayer);
        landslideRiskLayer = null;
      }
      landslideRiskGeojson = geojson;
      landslideRiskLayer = L.geoJSON(geojson, {
        style: styleLandslideRiskFeature,
        onEachFeature: onEachLandslideRiskFeature,
        pane: "landslidePane"
      });
      updateLayerVisibility();
      tryComputeVillageRisk();
    }

    function styleNaturalFeature(feature) {
      var props = feature && feature.properties ? feature.properties : {};
      var type = props.type || "";
      var fill = "rgba(16, 185, 129, 0.25)";
      var stroke = "#22c55e";
      if (type === "water") {
        fill = "rgba(56, 189, 248, 0.3)";
        stroke = "#38bdf8";
      } else if (type === "park") {
        fill = "rgba(74, 222, 128, 0.3)";
        stroke = "#22c55e";
      } else if (type === "forest") {
        fill = "rgba(22, 163, 74, 0.35)";
        stroke = "#16a34a";
      }
      return {
        color: stroke,
        weight: 1,
        opacity: 0.9,
        fillColor: fill,
        fillOpacity: 0.5
      };
    }

    function onEachNaturalFeature(feature, layer) {
      var props = feature && feature.properties ? feature.properties : {};
      var name =
        props.name ||
        "Area alami";
      var type = props.type || "";
      var html = "<strong>" + name + "</strong>";
      if (type) {
        html += "<br><small>Jenis: " + type + "</small>";
      }
      layer.bindPopup(html);
    }

    function createNaturalLayer(geojson) {
      if (naturalLayer) {
        map.removeLayer(naturalLayer);
        naturalLayer = null;
      }
      naturalLayer = L.geoJSON(geojson, {
        style: styleNaturalFeature,
        onEachFeature: onEachNaturalFeature
      });
      updateLayerVisibility();
    }

    function stylePlaceFeature(feature) {
      return {
        radius: 4,
        color: "#6366f1",
        weight: 1.5,
        fillColor: "#a5b4fc",
        fillOpacity: 0.9
      };
    }

    function onEachPlaceFeature(feature, layer) {
      var props = feature && feature.properties ? feature.properties : {};
      var name =
        props.name ||
        "Tempat";
      var type = props.type || "";
      var population = props.population;
      var html = "<strong>" + name + "</strong>";
      if (type) {
        html += "<br><small>Jenis: " + type + "</small>";
      }
      if (population !== null && typeof population !== "undefined") {
        html += "<br><small>Perkiraan penduduk: " + population + "</small>";
      }
      layer.bindPopup(html);
    }

    function createPlacesLayer(geojson) {
      if (placesLayer) {
        map.removeLayer(placesLayer);
        placesLayer = null;
      }
      placesLayer = L.geoJSON(geojson, {
        pointToLayer: function (feature, latlng) {
          return L.circleMarker(latlng, stylePlaceFeature(feature));
        },
        onEachFeature: onEachPlaceFeature
      });
      updateLayerVisibility();
    }

    function stylePoiFeature(feature) {
      return {
        radius: 3.5,
        color: "#f97316",
        weight: 1.5,
        fillColor: "#fed7aa",
        fillOpacity: 0.9
      };
    }

    function onEachPoiFeature(feature, layer) {
      var props = feature && feature.properties ? feature.properties : {};
      var name =
        props.name ||
        "Titik penting";
      var type = props.type || "";
      var html = "<strong>" + name + "</strong>";
      if (type) {
        html += "<br><small>Kategori: " + type + "</small>";
      }
      layer.bindPopup(html);
    }

    function createPoisLayer(geojson) {
      if (poisLayer) {
        map.removeLayer(poisLayer);
        poisLayer = null;
      }
      poisLayer = L.geoJSON(geojson, {
        pointToLayer: function (feature, latlng) {
          return L.circleMarker(latlng, stylePoiFeature(feature));
        },
        onEachFeature: onEachPoiFeature
      });
      updateLayerVisibility();
    }

    function createEwsIcon(url, borderColor) {
      return L.divIcon({
        className: "ews-icon-wrapper",
        html:
          '<img src="' +
          url +
          '" class="ews-icon-image" style="width: 32px; height: 32px; border-radius: 4px; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">',
        iconSize: [32, 32],
        iconAnchor: [16, 16],
        popupAnchor: [0, -18]
      });
    }

    function ensureEwsIcons() {
      if (ewsIconFlood && ewsIconGeo && ewsIconQuake && ewsIconMagma && ewsIconWeather && ewsIconUnknown) {
        return;
      }
      ewsIconFlood = createEwsIcon("orion/aquaguard.jpg", "#0ea5e9");
      ewsIconGeo = createEwsIcon("orion/slopeguard.jpg", "#f97316");
      ewsIconQuake = createEwsIcon("orion/seismoguard.jpg", "#ef4444");
      ewsIconMagma = createEwsIcon("orion/seismoguard.jpg", "#a855f7");
      ewsIconWeather = createEwsIcon("orion/aquaguard.jpg", "#22c55e");
      ewsIconUnknown = createEwsIcon("orion/aquaguard.jpg", "#22c55e");
    }

    function getEwsIconForType(type) {
      // Menggunakan marker default Leaflet untuk semua tipe Orion
      return L.icon({
        iconUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon.png',
        iconRetinaUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon-2x.png',
        shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png',
        iconSize: [25, 41],
        iconAnchor: [12, 41],
        popupAnchor: [1, -34],
        shadowSize: [41, 41]
      });
    }

    function getEwsTypeFromName(name) {
      if (!name) {
        return "unknown";
      }
      var n = String(name).toLowerCase();
      if (n.indexOf("floodguard") !== -1) {
        return "flood";
      }
      if (n.indexOf("geoshield") !== -1) {
        return "geo";
      }
      if (n.indexOf("quakealert") !== -1) {
        return "quake";
      }
      if (n.indexOf("magmashield") !== -1) {
        return "magma";
      }
      if (n.indexOf("weatherhub") !== -1) {
        return "weather";
      }
      return "unknown";
    }

    function rebuildEwsLayer() {
      if (!ewsData) {
        return;
      }

      if (ewsLayer) {
        map.removeLayer(ewsLayer);
        ewsLayer = null;
      }

      var showFlood = !filterEwsFloodCheckbox || filterEwsFloodCheckbox.checked;
      var showGeo = !filterEwsGeoCheckbox || filterEwsGeoCheckbox.checked;
      var showQuakeType = !filterEwsQuakeTypeCheckbox || filterEwsQuakeTypeCheckbox.checked;
      var showMagma = !filterEwsMagmaCheckbox || filterEwsMagmaCheckbox.checked;
      var showWeather = !filterEwsWeatherCheckbox || filterEwsWeatherCheckbox.checked;

      var markers = [];
      var newVillageAlertLookup = {};

      for (var i = 0; i < ewsData.length; i++) {
        var row = ewsData[i];
        if (!row) {
          continue;
        }

        var lat = typeof row.latitude === "number" ? row.latitude : parseFloat(row.latitude);
        var lng = typeof row.longitude === "number" ? row.longitude : parseFloat(row.longitude);
        if (!lat || !lng || isNaN(lat) || isNaN(lng)) {
          continue;
        }

        var name = row.name || "EWS";
        var type = row.type || getEwsTypeFromName(name);

        if (type === "flood" && !showFlood) {
          continue;
        }
        if (type === "geo" && !showGeo) {
          continue;
        }
        if (type === "quake" && !showQuakeType) {
          continue;
        }
        if (type === "magma" && !showMagma) {
          continue;
        }
        if (type === "weather" && !showWeather) {
          continue;
        }

        if (
          type === "unknown" &&
          !showFlood &&
          !showGeo &&
          !showQuakeType &&
          !showMagma &&
          !showWeather
        ) {
          continue;
        }

        var marker = L.marker([lat, lng], {
          icon: getEwsIconForType(type),
          pane: "ewsPane"
        });

        var location = row.location || "";
        var sensorCode = row.sensor_code || "";
        var status = row.status || "";
        var description = row.description || "";
        var level = typeof row.water_level_cm === "number"
          ? row.water_level_cm
          : (row.water_level_cm ? parseFloat(row.water_level_cm) : null);
        if (level !== null && isNaN(level)) {
          level = null;
        }
        var levelStatusRaw = row.level_status || "";
        var levelStatus = levelStatusRaw ? String(levelStatusRaw).toLowerCase() : "";
        var lastMeasuredAt = row.last_measured_at || "";
        var typeLabel = "";
        if (type === "flood") {
          typeLabel = "Orion FloodGuard";
        } else if (type === "geo") {
          typeLabel = "Orion GeoShield";
        } else if (type === "quake") {
          typeLabel = "Orion QuakeAlert";
        } else if (type === "magma") {
          typeLabel = "Orion MagmaShield";
        } else if (type === "weather") {
          typeLabel = "Orion WeatherHub";
        }

        var statusLabel = "";
        var statusClass = "";
        if (levelStatus) {
          if (levelStatus === "bahaya") {
            statusLabel = "Bahaya";
            statusClass = "ews-popup-status-bahaya";
          } else if (levelStatus === "siaga") {
            statusLabel = "Siaga";
            statusClass = "ews-popup-status-siaga";
          } else if (levelStatus === "waspada") {
            statusLabel = "Waspada";
            statusClass = "ews-popup-status-waspada";
          } else {
            statusLabel = "Normal";
            statusClass = "ews-popup-status-normal";
          }
        }

        if ((levelStatus === "siaga" || levelStatus === "bahaya") && location) {
          var normalizedLocation = normalizeVillageName(location);
          var candidates = [];
          if (normalizedLocation) {
            candidates.push(normalizedLocation);
            var parts = normalizedLocation.split(",");
            for (var p = 0; p < parts.length; p++) {
              var part = parts[p].trim();
              if (part) {
                candidates.push(part);
              }
            }
            var desaMatch = normalizedLocation.match(/desa\s+([^,]+)/);
            if (desaMatch && desaMatch[1]) {
              var desaName = desaMatch[1].trim();
              if (desaName) {
                candidates.push(desaName);
              }
            }
          }
          for (var c = 0; c < candidates.length; c++) {
            var candidateKey = candidates[c];
            if (candidateKey) {
              newVillageAlertLookup[candidateKey] = levelStatus;
            }
          }
        }

        var measurementLabel = "";
        var measurementUnit = "";
        if (type === "flood") {
          measurementLabel = "Level air sungai";
          measurementUnit = "cm";
        } else if (type === "geo") {
          measurementLabel = "Pergerakan tanah";
          measurementUnit = "cm";
        } else if (type === "quake") {
          measurementLabel = "Level getaran tanah";
          measurementUnit = "";
        } else if (type === "magma") {
          measurementLabel = "Level aktivitas";
          measurementUnit = "";
        } else if (type === "weather") {
          measurementLabel = "Indikator cuaca";
          measurementUnit = "";
        } else {
          measurementLabel = "Level pemantauan";
          measurementUnit = "";
        }

        var html = '<div class="ews-popup">';
        html += '<div class="ews-popup-header">';
        html += '<div class="ews-popup-title">' + name + "</div>";
        if (typeLabel) {
          html += '<div class="ews-popup-chip">' + typeLabel + "</div>";
        }
        html += "</div>";
        html += '<div class="ews-popup-body">';
        html += '<div class="ews-popup-level">';
        if (level !== null) {
          html += '<span class="ews-popup-level-value">' + level.toFixed(0) + "</span>";
          if (measurementUnit) {
            html += '<span class="ews-popup-level-unit">' + measurementUnit + "</span>";
          }
        } else {
          html += '<span class="ews-popup-level-value">-</span>';
          if (measurementUnit) {
            html += '<span class="ews-popup-level-unit">' + measurementUnit + "</span>";
          }
        }
        html += "</div>";
        if (statusLabel) {
          html += '<div class="ews-popup-status-pill ' + statusClass + '">' + statusLabel + "</div>";
        }
        html += '<div class="ews-popup-meta">';
        if (measurementLabel) {
          html += "<div><strong>Parameter pantau:</strong> " + measurementLabel + "</div>";
        }
        if (sensorCode) {
          html += "<div><strong>Kode:</strong> " + sensorCode + "</div>";
        }
        if (location) {
          html += "<div><strong>Lokasi:</strong> " + location + "</div>";
        }
        if (status) {
          html += "<div><strong>Status perangkat:</strong> " + status + "</div>";
        }
        if (lastMeasuredAt) {
          html += "<div><strong>Update level:</strong> " + lastMeasuredAt + "</div>";
        }
        if (description) {
          html += "<div>" + description + "</div>";
        }
        html += '<div class="ews-popup-controls">';
        if (sensorCode) {
          var safeSensorCode = String(sensorCode).replace(/"/g, "&quot;");
          html +=
            '<button class="ews-control-button" data-ews-command="reboot" data-ews-sensor="' +
            safeSensorCode +
            '">Reboot</button>';
          html +=
            '<button class="ews-control-button" data-ews-command="reset" data-ews-sensor="' +
            safeSensorCode +
            '">Reset</button>';
          html +=
            '<button class="ews-control-button" data-ews-command="update" data-ews-sensor="' +
            safeSensorCode +
            '">Update</button>';
          html +=
            '<button class="ews-control-button" data-ews-command="shutdown" data-ews-sensor="' +
            safeSensorCode +
            '">Shutdown</button>';
        }
        html += "</div>";
        html += "</div>";
        html += "</div>";

        marker.bindPopup(html);
        if (type === "geo") {
          (function (markerRef, baseHtml, latRef, lngRef) {
            fetchRainForecast(latRef, lngRef).then(function (forecast) {
              if (!forecast) {
                return;
              }
              var summary = summarizeNextHoursRain(forecast, 6);
              if (!summary || typeof summary.total !== "number") {
                return;
              }
              var label = summary.label || "";
              var extra = "<div class=\"ews-popup-meta\"><div><strong>Hujan 6 jam ke depan:</strong> " +
                summary.total.toFixed(1) +
                " mm";
              if (label) {
                extra += " (" + label + ")";
              }
              extra += "</div></div>";
              var popup = markerRef.getPopup();
              if (popup) {
                popup.setContent(baseHtml + extra);
              }
            });
          })(marker, html, lat, lng);
        } else if (type === "flood") {
          (function (markerRef, baseHtml, latRef, lngRef) {
            fetchFloodForecast(latRef, lngRef).then(function (forecast) {
              if (!forecast) {
                return;
              }
              var summaryToday = summarizeFloodToday(forecast);
              var summaryNext3 = summarizeFloodNext3Days(forecast);
              if (!summaryToday || typeof summaryToday.discharge !== "number") {
                return;
              }
              var labelToday = summaryToday.label || "";
              var extra = "<div class=\"ews-popup-meta\">";
              extra += "<div><strong>Perkiraan debit sungai utama hari ini:</strong> " +
                summaryToday.discharge.toFixed(1) +
                " mÂ³/s";
              if (labelToday) {
                extra += " (" + labelToday + ")";
              }
              extra += "</div>";
              if (summaryNext3 && typeof summaryNext3.maxDischarge === "number") {
                var label3 = summaryNext3.label || "";
                extra += "<div><strong>Maksimum debit 3 hari ke depan:</strong> " +
                  summaryNext3.maxDischarge.toFixed(1) +
                  " mÂ³/s";
                if (label3) {
                  extra += " (" + label3 + ")";
                }
                extra += "</div>";
              }
              extra += "</div>";
              var popup = markerRef.getPopup();
              if (popup) {
                popup.setContent(baseHtml + extra);
              }
            });
          })(marker, html, lat, lng);
        }
        markers.push(marker);
      }

      villageAlertLookup = newVillageAlertLookup;
      if (villageLayer) {
        villageLayer.setStyle(function (feature) {
          return styleVillageFeature(feature);
        });
      }

      ewsLayer = L.layerGroup(markers);
      updateLayerVisibility();
    }

    function sendEwsControlCommand(sensorCode, command, buttonEl) {
      if (!sensorCode || !command) {
        return;
      }
      var params = new URLSearchParams();
      params.append("sensor_code", sensorCode);
      params.append("command", command);
      if (buttonEl) {
        buttonEl.disabled = true;
      }
      fetch("ews_api.php?action=control", {
        method: "POST",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded;charset=UTF-8"
        },
        body: params.toString()
      })
        .then(function (response) {
          if (!response.ok) {
            throw new Error("HTTP " + response.status + " saat mengirim perintah EWS");
          }
          return response.json();
        })
        .then(function (json) {
          if (!json || !json.success) {
            throw new Error(json && json.error ? json.error : "Respon EWS control tidak valid");
          }
          var stationName = json.station && json.station.name ? json.station.name : sensorCode;
          setStatus(
            "Perintah " + command + " untuk " + stationName + " berhasil dikirim.",
            "ok"
          );
        })
        .catch(function (error) {
          setStatus(
            "Gagal mengirim perintah EWS: " +
              (error && error.message ? error.message : "galat tak dikenal"),
            "error"
          );
        })
        .finally(function () {
          if (buttonEl) {
            buttonEl.disabled = false;
          }
        });
    }

    function loadEwsLayer() {
      setStatus("Memuat lokasi EWS dari serverâ€¦", "loading");
      fetch("ews_api.php?action=list")
        .then(function (response) {
          if (!response.ok) {
            throw new Error("HTTP " + response.status + " saat memuat lokasi EWS");
          }
          return response.json();
        })
        .then(function (json) {
          if (!json || !json.success || !Array.isArray(json.data)) {
            throw new Error("Respon EWS tidak valid");
          }
          ewsData = json.data;
          rebuildEwsLayer();
          setStatus("Lokasi EWS telah dimuat dari database.", "ok");
        })
        .catch(function (error) {
          setStatus(
            "Gagal memuat lokasi EWS: " +
              (error && error.message ? error.message : "galat tak dikenal"),
            "error"
          );
        });
    }

    function loadGroundwaterLayer() {
      if (groundwaterLayer) {
        updateLayerVisibility();
        return;
      }
      setStatus("Memuat Peta Air Tanah (sumur air tanah BIG)â€¦", "loading");
      var url =
        "https://kspservices.big.go.id/satupeta/rest/services/PUBLIK/SUMBER_DAYA_ALAM_DAN_LINGKUNGAN/MapServer/1/query" +
        "?where=" +
        encodeURIComponent("kabupaten = 'BANJARNEGARA'") +
        "&outFields=*" +
        "&f=geojson" +
        "&resultRecordCount=1000";
      fetch(url)
        .then(function (response) {
          if (!response.ok) {
            throw new Error("HTTP " + response.status + " saat memuat Peta Air Tanah");
          }
          return response.json();
        })
        .then(function (geojson) {
          groundwaterLayer = L.geoJSON(geojson, {
            pointToLayer: function (feature, latlng) {
              return L.circleMarker(latlng, {
                radius: 4,
                color: "#3a00a6",
                weight: 1,
                fillColor: "#3a00a6",
                fillOpacity: 0.9
              });
            },
            onEachFeature: function (feature, layer) {
              var props = feature && feature.properties ? feature.properties : {};
              var name = props.nm_sumur || props.nm_inf || "Sumur air tanah";
              var desa = props.desa || "";
              var kecamatan = props.kecamatan || "";
              var kabupaten = props.kabupaten || "";
              var tahun = props.thn_dat || "";
              var debit = props.dbt_air_baku || "";
              var kedalaman = props.kdlm_at || "";
              var html = "<strong>" + name + "</strong>";
              if (desa || kecamatan || kabupaten) {
                html += "<br><small>";
                if (desa) {
                  html += "Desa " + desa;
                }
                if (kecamatan) {
                  html += (desa ? ", " : "") + "Kec. " + kecamatan;
                }
                if (kabupaten) {
                  html += (desa || kecamatan ? ", " : "") + kabupaten;
                }
                html += "</small>";
              }
              if (tahun) {
                html += "<br><small>Tahun data: " + tahun + "</small>";
              }
              if (kedalaman) {
                html += "<br><small>Kedalaman sumur: " + kedalaman + "</small>";
              }
              if (debit) {
                html += "<br><small>Debit air baku: " + debit + "</small>";
              }
              layer.bindPopup(html);
            }
          });
          updateLayerVisibility();
          setStatus("Peta Air Tanah BIG untuk Banjarnegara telah dimuat.", "ok");
        })
        .catch(function (error) {
          setStatus(
            "Gagal memuat Peta Air Tanah BIG: " +
              (error && error.message ? error.message : "galat tak dikenal"),
            "error"
          );
        });
    }

    document.addEventListener("click", function (event) {
      var target = event.target;
      if (!target || !target.classList || !target.classList.contains("ews-control-button")) {
        return;
      }
      var sensorCode = target.getAttribute("data-ews-sensor");
      var command = target.getAttribute("data-ews-command");
      sendEwsControlCommand(sensorCode, command, target);
    });

    function createWaterLayers(geojson) {
      clearWaterLayers();

      var baseOptions = {
        style: function (feature) {
          return styleForFeature(feature);
        },
        onEachFeature: onEachWaterFeature
      };

      waterRiversLayer = L.geoJSON(geojson, Object.assign({}, baseOptions, {
        filter: function (feature) {
          var tags = feature && feature.properties && feature.properties.tags ? feature.properties.tags : {};
          return getFeatureCategory(tags) === "river";
        }
      }));

      waterLakesLayer = L.geoJSON(geojson, Object.assign({}, baseOptions, {
        filter: function (feature) {
          var tags = feature && feature.properties && feature.properties.tags ? feature.properties.tags : {};
          return getFeatureCategory(tags) === "lake";
        }
      }));

      waterIrrigationLayer = L.geoJSON(geojson, Object.assign({}, baseOptions, {
        filter: function (feature) {
          var tags = feature && feature.properties && feature.properties.tags ? feature.properties.tags : {};
          return getFeatureCategory(tags) === "irrigation";
        }
      }));

      updateLayerVisibility();
    }

    function updateLayerVisibility() {
      if (!map) {
        return;
      }

      if (waterRiversLayer) {
        if (!filterRiversCheckbox || filterRiversCheckbox.checked) {
          map.addLayer(waterRiversLayer);
        } else {
          map.removeLayer(waterRiversLayer);
        }
      }

      if (localRiversLayer) {
        if (!filterLocalRiversCheckbox || filterLocalRiversCheckbox.checked) {
          map.addLayer(localRiversLayer);
        } else {
          map.removeLayer(localRiversLayer);
        }
      }

      if (waterLakesLayer) {
        if (!filterLakesCheckbox || filterLakesCheckbox.checked) {
          map.addLayer(waterLakesLayer);
        } else {
          map.removeLayer(waterLakesLayer);
        }
      }

      if (waterIrrigationLayer) {
        if (!filterIrrigationCheckbox || filterIrrigationCheckbox.checked) {
          map.addLayer(waterIrrigationLayer);
        } else {
          map.removeLayer(waterIrrigationLayer);
        }
      }
      if (villageLayer) {
        if (!filterVillagesCheckbox || filterVillagesCheckbox.checked) {
          map.addLayer(villageLayer);
        } else {
          map.removeLayer(villageLayer);
        }
      }
      if (roadsLayer) {
        if (!filterRoadsCheckbox || filterRoadsCheckbox.checked) {
          map.addLayer(roadsLayer);
        } else {
          map.removeLayer(roadsLayer);
        }
      }
      if (roadSectionsLayer) {
        if (!filterRoadSectionsCheckbox || filterRoadSectionsCheckbox.checked) {
          map.addLayer(roadSectionsLayer);
        } else {
          map.removeLayer(roadSectionsLayer);
        }
      }
      if (buildingsLayer) {
        if (!filterBuildingsCheckbox || filterBuildingsCheckbox.checked) {
          map.addLayer(buildingsLayer);
        } else {
          map.removeLayer(buildingsLayer);
        }
      }
      if (contourLayer) {
        if (!filterContoursCheckbox || filterContoursCheckbox.checked) {
          map.addLayer(contourLayer);
        } else {
          map.removeLayer(contourLayer);
        }
      }
      if (landslideRiskLayer) {
        if (!filterLandslideRiskCheckbox || filterLandslideRiskCheckbox.checked) {
          map.addLayer(landslideRiskLayer);
        } else {
          map.removeLayer(landslideRiskLayer);
        }
      }
      if (naturalLayer) {
        if (!filterNaturalCheckbox || filterNaturalCheckbox.checked) {
          map.addLayer(naturalLayer);
        } else {
          map.removeLayer(naturalLayer);
        }
      }
      if (placesLayer) {
        if (!filterPlacesCheckbox || filterPlacesCheckbox.checked) {
          map.addLayer(placesLayer);
        } else {
          map.removeLayer(placesLayer);
        }
      }
      if (poisLayer) {
        if (!filterPoisCheckbox || filterPoisCheckbox.checked) {
          map.addLayer(poisLayer);
        } else {
          map.removeLayer(poisLayer);
        }
      }
      if (rainLayer) {
        if (!filterRainCheckbox || filterRainCheckbox.checked) {
          map.addLayer(rainLayer);
        } else {
          map.removeLayer(rainLayer);
        }
      }
      if (climateDJFLayer) {
        if (!filterClimateDJFCheckbox || filterClimateDJFCheckbox.checked) {
          map.addLayer(climateDJFLayer);
        } else {
          map.removeLayer(climateDJFLayer);
        }
      }
      if (climateMAMLayer) {
        if (!filterClimateMAMCheckbox || filterClimateMAMCheckbox.checked) {
          map.addLayer(climateMAMLayer);
        } else {
          map.removeLayer(climateMAMLayer);
        }
      }
      if (climateJJALayer) {
        if (!filterClimateJJACheckbox || filterClimateJJACheckbox.checked) {
          map.addLayer(climateJJALayer);
        } else {
          map.removeLayer(climateJJALayer);
        }
      }
      if (climateSONLayer) {
        if (!filterClimateSONCheckbox || filterClimateSONCheckbox.checked) {
          map.addLayer(climateSONLayer);
        } else {
          map.removeLayer(climateSONLayer);
        }
      }
      if (quakesLayer) {
        if (!filterQuakesCheckbox || filterQuakesCheckbox.checked) {
          map.addLayer(quakesLayer);
        } else {
          map.removeLayer(quakesLayer);
        }
      }
      if (seismicJateng2021Layer) {
        if (!filterSeismicJateng2021Checkbox || filterSeismicJateng2021Checkbox.checked) {
          map.addLayer(seismicJateng2021Layer);
        } else {
          map.removeLayer(seismicJateng2021Layer);
        }
      }
      if (groundwaterLayer) {
        if (!filterGroundwaterCheckbox || filterGroundwaterCheckbox.checked) {
          map.addLayer(groundwaterLayer);
        } else {
          map.removeLayer(groundwaterLayer);
        }
      }
      if (soilLayer) {
        if (!filterSoilCheckbox || filterSoilCheckbox.checked) {
          map.addLayer(soilLayer);
        } else {
          map.removeLayer(soilLayer);
        }
      }
      if (ewsLayer) {
        if (!filterEwsCheckbox || filterEwsCheckbox.checked) {
          map.addLayer(ewsLayer);
        } else {
          map.removeLayer(ewsLayer);
        }
      }
    }

    function loadDisasterGeoJSON() {
      console.log('loadDisasterGeoJSON called');
      
      // Get selected year
      const yearSelect = document.getElementById('disasterYearSelect');
      const selectedYear = yearSelect ? yearSelect.value : '2024';
      
      setStatus("Memuat data bencana Banjarnegara " + selectedYear + "...", "loading");
      
      // Load appropriate GeoJSON file based on year
      const geoJsonFile = 'geojson/bencana-banjarnegara-' + selectedYear + '.geojson';
      console.log('Loading GeoJSON file:', geoJsonFile);
      
      fetch(geoJsonFile)
        .then(response => {
          if (!response.ok) {
            throw new Error('File bencana tidak ditemukan');
          }
          return response.json();
        })
        .then(geojson => {
          console.log('GeoJSON loaded successfully');
          console.log('Total features:', geojson.features ? geojson.features.length : 0);
          
          if (geojson && geojson.type === "FeatureCollection" && Array.isArray(geojson.features)) {
            // Create disaster layer
            if (window.disasterLayer) {
              map.removeLayer(window.disasterLayer);
              window.disasterLayer = null;
            }
            
            window.disasterLayer = L.geoJSON(geojson, {
              pointToLayer: function(feature, latlng) {
                // Custom marker for disasters
                return L.marker(latlng, {
                  icon: L.divIcon({
                    className: 'disaster-marker',
                    html: '<div style="background: #ff4444; color: white; border-radius: 50%; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 2px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">âš ï¸</div>',
                    iconSize: [24, 24],
                    iconAnchor: [12, 12]
                  })
                });
              },
              onEachFeature: function(feature, layer) {
                // Create popup content
                let popupContent = '<div style="max-width: 300px;">';
                popupContent += '<h3 style="margin: 0 0 8px 0; color: #ff4444;">' + (feature.properties.name || 'Bencana') + '</h3>';
                
                if (feature.properties.description) {
                  // Clean up HTML from description
                  let cleanDesc = feature.properties.description.replace(/<br\s*\/?>/gi, '\n').replace(/<[^>]*>/g, '');
                  popupContent += '<p style="margin: 0 0 8px 0; font-size: 14px;">' + cleanDesc.replace(/\n/g, '<br>') + '</p>';
                }
                
                const jenisBencana = feature.properties['JENIS KEJADIAN'] || feature.properties['JENIS_KEJADIAN'];
                if (jenisBencana) {
                  popupContent += '<p style="margin: 0 0 4px 0; font-weight: bold;">Jenis: ' + jenisBencana + '</p>';
                }
                
                if (feature.properties['WAKTU KEJADIAN']) {
                  popupContent += '<p style="margin: 0 0 4px 0;">Waktu: ' + feature.properties['WAKTU KEJADIAN'] + '</p>';
                }
                
                popupContent += '</div>';
                
                layer.bindPopup(popupContent);
              }
            });
              
              console.log('Disaster layer created successfully');
              // Store the original GeoJSON data for filtering
              window.disasterGeoJSONData = geojson;
              console.log('GeoJSON data stored for filtering:', geojson.features.length + ' features');
              
              setStatus("Data bencana Banjarnegara " + selectedYear + " berhasil dimuat (" + geojson.features.length + " kejadian)", "ok");
              
              // Add layer to map first, then filter based on checkboxes
              if (window.disasterLayer) {
                map.addLayer(window.disasterLayer);
                console.log('Disaster layer added to map');
              } else {
                console.log('Disaster layer is null, cannot add to map');
              }
              
              // Update visibility based on checkbox selection
              updateDisasterLayerVisibility();
          } else {
            throw new Error('Format GeoJSON tidak valid');
          }
        })
        .catch(error => {
          setStatus("Tidak dapat memuat data bencana: " + error.message, "warning");
        });
    }

    // Add event listener for year selector
    document.addEventListener('DOMContentLoaded', function() {
      const yearSelect = document.getElementById('disasterYearSelect');
      if (yearSelect) {
        yearSelect.addEventListener('change', function() {
          console.log('Year selection changed to:', this.value);
          // Reload disaster data when year changes
          if (window.disasterLayer) {
            map.removeLayer(window.disasterLayer);
            window.disasterLayer = null;
            window.disasterGeoJSONData = null;
          }
          loadDisasterGeoJSON();
        });
      }
    });

    function updateDisasterLayerVisibility() {
      console.log('updateDisasterLayerVisibility called');
      if (!map) {
        console.log('Map not available');
        return;
      }

      // Load disaster data if any checkbox is checked and data not loaded yet
      const anyDisasterChecked = (filterKebakaranCheckbox && filterKebakaranCheckbox.checked) ||
                               (filterLongsorCheckbox && filterLongsorCheckbox.checked) ||
                               (filterAnginCheckbox && filterAnginCheckbox.checked) ||
                               (filterPohonCheckbox && filterPohonCheckbox.checked) ||
                               (filterOrangHilangCheckbox && filterOrangHilangCheckbox.checked);

      console.log('Any disaster checked:', anyDisasterChecked);
      console.log('Disaster layer exists:', !!window.disasterLayer);

      if (anyDisasterChecked && !window.disasterLayer) {
          console.log('Loading disaster data...');
          loadDisasterGeoJSON();
          return; // loadDisasterGeoJSON will call this function again when done
        }
        
        // If layer already exists, apply filtering immediately
        if (window.disasterLayer && window.disasterGeoJSONData) {
          console.log('Applying filtering to existing layer...');
          
          const selectedCategories = [];
          if (filterKebakaranCheckbox && filterKebakaranCheckbox.checked) {
            selectedCategories.push('Kebakaran');
          }
          if (filterLongsorCheckbox && filterLongsorCheckbox.checked) {
            selectedCategories.push('Longsor'); // Untuk Tanah Longsor/Tanah longsor
          }
          if (filterAnginCheckbox && filterAnginCheckbox.checked) {
            selectedCategories.push('Angin kencang');
          }
          if (filterPohonCheckbox && filterPohonCheckbox.checked) {
            selectedCategories.push('pohon tumbang');
            selectedCategories.push('tumbang');
          }
          if (filterOrangHilangCheckbox && filterOrangHilangCheckbox.checked) {
            selectedCategories.push('Orang hilang');
            selectedCategories.push('hilang');
          }
          
          console.log('Selected categories for filtering:', selectedCategories);
          console.log('Total features available:', window.disasterGeoJSONData.features.length);
          
          // Handle the case where no checkboxes are checked - show all features
          if (selectedCategories.length === 0) {
            console.log('No categories selected, hiding all features');
            // Remove existing layer to hide all features when no checkboxes are checked
            if (window.disasterLayer) {
              map.removeLayer(window.disasterLayer);
              window.disasterLayer = null;
            }
            return; // Exit function early
          } else {
            // Filter the features and create a new layer with only selected features
            console.log('Starting filtering process...');
            const filteredFeatures = window.disasterGeoJSONData.features.filter(feature => {
              // Get the disaster type from the feature
              let jenis1 = feature.properties['JENIS KEJADIAN'] || feature.properties['JENIS_KEJADIAN'] || 
                          feature.properties['Jenis Kejadian'] || feature.properties['jenis_kejadian'] || '';
              
              // Get description and other fields that might contain disaster information
              const description = feature.properties['description'] || feature.properties['Description'] || feature.properties['DESCRIPTION'] || '';
              const dampakBangunan = feature.properties['DAMPAK_Bangunan'] || feature.properties['DAMPAK Bangunan'] || '';
              const kondisiUmum = feature.properties['KRONOLOGI_KONDISI_UMUM'] || feature.properties['KONDISI UMUM'] || '';
              
              // Combine all text fields for comprehensive searching
              const allText = (jenis1 + ' ' + description + ' ' + dampakBangunan + ' ' + kondisiUmum).toLowerCase();
              
              // Normalize the disaster type
              let normalizedJenis = jenis1.toLowerCase().trim();
              
              // Handle special cases for disaster types
              if (normalizedJenis === 'tanah longsor') {
                normalizedJenis = 'longsor';
              } else if (normalizedJenis === 'angin kencang') {
                normalizedJenis = 'angin';
              }
              
              // Check if this feature matches any selected category
              const shouldInclude = selectedCategories.some(cat => {
                const normalizedCat = cat.toLowerCase().trim();
                
                // For 'longsor' category, check if disaster type contains 'longsor'
                if (normalizedCat === 'longsor') {
                  return normalizedJenis.includes('longsor');
                }
                
                // For 'kebakaran' category, check if disaster type is exactly 'kebakaran'
                if (normalizedCat === 'kebakaran') {
                  return normalizedJenis === 'kebakaran';
                }
                
                // For 'angin kencang' category, check if disaster type contains 'angin'
                if (normalizedCat === 'angin kencang' || normalizedCat === 'angin') {
                  return normalizedJenis.includes('angin');
                }
                
                // For 'pohon tumbang' or 'tumbang' categories - search in all text fields
                if (normalizedCat === 'pohon tumbang' || normalizedCat === 'tumbang') {
                  return allText.includes('pohon') || allText.includes('tumbang');
                }
                
                // For 'orang hilang' or 'hilang' categories - search in all text fields
                if (normalizedCat === 'orang hilang' || normalizedCat === 'hilang') {
                  return allText.includes('hilang') && !allText.includes('ikan') && !allText.includes('barang'); // Exclude ikan hilang, barang hilang
                }
                
                // Default: exact match
                return normalizedJenis === normalizedCat;
              });
              
              if (shouldInclude) {
                console.log('INCLUDING feature with jenis1:', jenis1, 'normalized:', normalizedJenis, 'for categories:', selectedCategories);
                if (selectedCategories.some(cat => cat.toLowerCase().includes('pohon'))) {
                  console.log('  Found pohon match! allText contains:', allText.includes('pohon'), 'tumbang:', allText.includes('tumbang'));
                }
              }
              
              return shouldInclude;
            });
            
            console.log('Filtered features count:', filteredFeatures.length, 'from total:', window.disasterGeoJSONData.features.length);
            if (filteredFeatures.length > 0) {
              console.log('First few filtered features:');
              filteredFeatures.slice(0, 5).forEach((feature, index) => {
                let jenis1 = feature.properties['JENIS KEJADIAN'] || feature.properties['JENIS_KEJADIAN'] || 
                            feature.properties['Jenis Kejadian'] || feature.properties['jenis_kejadian'] || '';
                console.log(`  ${index + 1}. ${jenis1}`);
              });
            } else {
              console.log('No features matched the filtering criteria!');
            }
            console.log('First few filtered features:', filteredFeatures.slice(0, 3));
            
            // Remove existing layer and create new one with filtered features
            if (window.disasterLayer) {
              map.removeLayer(window.disasterLayer);
            }
            
            window.disasterLayer = L.geoJSON({type: 'FeatureCollection', features: filteredFeatures}, {
              pointToLayer: function(feature, latlng) {
                return L.marker(latlng, {
                  icon: L.divIcon({
                    className: 'disaster-marker',
                    html: '<div style="background: #ff4444; color: white; border-radius: 50%; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 2px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">âš ï¸</div>',
                    iconSize: [24, 24],
                    iconAnchor: [12, 12]
                  })
                });
              },
              onEachFeature: function(feature, layer) {
                let popupContent = '<div style="max-width: 300px;">';
                popupContent += '<h3 style="margin: 0 0 8px 0; color: #ff4444;">' + (feature.properties.name || 'Bencana') + '</h3>';
                
                if (feature.properties.description) {
                  let cleanDesc = feature.properties.description.replace(/<br\s*\/?>/gi, '\n').replace(/<[^>]*>/g, '');
                  popupContent += '<p style="margin: 0 0 8px 0; font-size: 14px;">' + cleanDesc.replace(/\n/g, '<br>') + '</p>';
                }
                
                const jenisBencana = feature.properties['JENIS KEJADIAN'] || feature.properties['JENIS_KEJADIAN'];
                if (jenisBencana) {
                  popupContent += '<p style="margin: 0 0 4px 0; font-weight: bold;">Jenis: ' + jenisBencana + '</p>';
                }
                
                if (feature.properties['WAKTU KEJADIAN']) {
                  popupContent += '<p style="margin: 0 0 4px 0;">Waktu: ' + feature.properties['WAKTU KEJADIAN'] + '</p>';
                }
                
                popupContent += '</div>';
                
                layer.bindPopup(popupContent);
              }
            });
            
            map.addLayer(window.disasterLayer);
          }
        }
    }

    function loadWaterData() {
      toggleLoading(true);

      clearWaterLayers();
      waterLayer = null;

      var query = buildOverpassQuery(banjarnegaraBBox);
      var lastErrorMessage = "";

      function tryFetchFromEndpoint(index) {
        if (index >= overpassEndpoints.length) {
          toggleLoading(false);
          setStatus("Gagal memuat data air permukaan: " + lastErrorMessage, "error");
          return;
        }

        var overpassUrl = overpassEndpoints[index];

        fetch(overpassUrl, {
          method: "POST",
          body: query,
          headers: {
            "Content-Type": "text/plain;charset=UTF-8"
          }
        })
          .then(function (response) {
            if (!response.ok) {
              lastErrorMessage = "HTTP " + response.status + " dari server " + (index + 1);
              if (response.status >= 500 || response.status === 429) {
                tryFetchFromEndpoint(index + 1);
                return null;
              }
              throw new Error(lastErrorMessage);
            }
            return response.json();
          })
        .then(function (data) {
          if (!data) {
            return;
          }
          var geojson = overpassToGeoJSON(data);
          loadGeoJSONObject(geojson, "Overpass API");
          toggleLoading(false);
        })
          .catch(function (error) {
            if (error && (index + 1) < overpassEndpoints.length) {
              lastErrorMessage = error.message || "galat jaringan";
              tryFetchFromEndpoint(index + 1);
              return;
            }
            toggleLoading(false);
            setStatus("Gagal memuat data air permukaan: " + (error && error.message ? error.message : "galat tak dikenal"), "error");
          });
      }

      tryFetchFromEndpoint(0);
    }

    function loadVillageBoundaries() {
      fetch("geojson/peta_desa.geojson")
        .then(function (response) {
          if (!response.ok) {
            throw new Error("HTTP " + response.status + " saat memuat batas desa");
          }
          return response.json();
        })
        .then(function (geojson) {
          createVillageLayer(geojson);
        })
        .catch(function (error) {
          setStatus(
            "Gagal memuat batas desa: " +
              (error && error.message ? error.message : "galat tak dikenal"),
            "error"
          );
        });
    }

    function loadLocalRiversLayer() {
      fetch("geojson/sungai.geojson")
        .then(function (response) {
          if (!response.ok) {
            throw new Error("HTTP " + response.status + " saat memuat sungai lokal");
          }
          return response.json();
        })
        .then(function (geojson) {
          createLocalRiversLayer(geojson);
        })
        .catch(function (error) {
          setStatus(
            "Gagal memuat sungai lokal: " +
              (error && error.message ? error.message : "galat tak dikenal"),
            "error"
          );
        });
    }

    function loadContourLayer() {
      fetch("geojson/kontur-banjarnegara.geojson")
        .then(function (response) {
          if (!response.ok) {
            throw new Error("HTTP " + response.status + " saat memuat kontur tanah");
          }
          return response.json();
        })
        .then(function (geojson) {
          createContourLayer(geojson);
        })
        .catch(function (error) {
          setStatus(
            "Gagal memuat kontur tanah: " +
              (error && error.message ? error.message : "galat tak dikenal"),
            "error"
          );
        });
    }

    function loadRoadsLayer() {
      fetch("geojson/jalan.geojson")
        .then(function (response) {
          if (!response.ok) {
            throw new Error("HTTP " + response.status + " saat memuat jalan");
          }
          return response.json();
        })
        .then(function (geojson) {
          createRoadsLayer(geojson);
        })
        .catch(function (error) {
          setStatus(
            "Gagal memuat jalan: " +
              (error && error.message ? error.message : "galat tak dikenal"),
            "error"
          );
        });
    }

    function loadBuildingsLayer() {
      fetch("geojson/buildings_banjarnegara.geojson")
        .then(function (response) {
          if (!response.ok) {
            throw new Error("HTTP " + response.status + " saat memuat bangunan");
          }
          return response.json();
        })
        .then(function (geojson) {
          createBuildingsLayer(geojson);
        })
        .catch(function (error) {
          setStatus(
            "Gagal memuat bangunan: " +
              (error && error.message ? error.message : "galat tak dikenal"),
            "error"
          );
        });
    }

    function loadNaturalLayer() {
      fetch("geojson/natural.geojson")
        .then(function (response) {
          if (!response.ok) {
            throw new Error("HTTP " + response.status + " saat memuat area alami");
          }
          return response.json();
        })
        .then(function (geojson) {
          createNaturalLayer(geojson);
        })
        .catch(function (error) {
          setStatus(
            "Gagal memuat area alami: " +
              (error && error.message ? error.message : "galat tak dikenal"),
            "error"
          );
        });
    }

    function buildSeismic2021Url(layerId) {
      var bbox =
        banjarnegaraBBox.west + "," +
        banjarnegaraBBox.south + "," +
        banjarnegaraBBox.east + "," +
        banjarnegaraBBox.north;
      var params = new URLSearchParams({
        where: "1=1",
        geometry: bbox,
        geometryType: "esriGeometryEnvelope",
        inSR: "4326",
        spatialRel: "esriSpatialRelIntersects",
        outFields: "*",
        outSR: "4326",
        f: "geojson"
      });
      return "https://gis.bmkg.go.id/arcgis/rest/services/Peta_Seismisitas_Tahun_2021_new/MapServer/" +
        layerId +
        "/query?" +
        params.toString();
    }

    function createSeismicJateng2021Layer(collections) {
      if (seismicJateng2021Layer) {
        map.removeLayer(seismicJateng2021Layer);
        seismicJateng2021Layer = null;
      }
      var merged = {
        type: "FeatureCollection",
        features: []
      };
      var depthKeys = ["dangkal", "menengah", "dalam"];
      for (var i = 0; i < collections.length; i++) {
        var col = collections[i];
        if (!col || !Array.isArray(col.features)) {
          continue;
        }
        var depthLabel = depthKeys[i] || "";
        for (var j = 0; j < col.features.length; j++) {
          var f = col.features[j];
          if (!f || !f.geometry) {
            continue;
          }
          if (!f.properties) {
            f.properties = {};
          }
          f.properties.kedalaman_kategori = depthLabel;
          merged.features.push(f);
        }
      }
      seismicJateng2021Layer = L.geoJSON(merged, {
        pointToLayer: function (feature, latlng) {
          var props = feature && feature.properties ? feature.properties : {};
          var mag = typeof props.magnitudo === "number" ? props.magnitudo : null;
          var radius = 4;
          if (mag !== null && !isNaN(mag)) {
            radius = 3 + mag * 1.5;
            if (radius < 3) {
              radius = 3;
            }
            if (radius > 12) {
              radius = 12;
            }
          }
          var depthCat = props.kedalaman_kategori || "";
          var color = "#f97316";
          if (depthCat === "dangkal") {
            color = "#22c55e";
          } else if (depthCat === "menengah") {
            color = "#eab308";
          } else if (depthCat === "dalam") {
            color = "#6366f1";
          }
          return L.circleMarker(latlng, {
            radius: radius,
            color: color,
            weight: 1.4,
            fillColor: color,
            fillOpacity: 0.8
          });
        },
        onEachFeature: function (feature, layer) {
          var props = feature && feature.properties ? feature.properties : {};
          var mag = typeof props.magnitudo === "number" ? props.magnitudo : null;
          var kedalaman = typeof props.kedalaman === "number" ? props.kedalaman : null;
          var tanggal = props.tanggal || "";
          var jam = props.jam || "";
          var depthCat = props.kedalaman_kategori || "";
          var depthLabel = "";
          if (depthCat === "dangkal") {
            depthLabel = "Dangkal";
          } else if (depthCat === "menengah") {
            depthLabel = "Menengah";
          } else if (depthCat === "dalam") {
            depthLabel = "Dalam";
          }
          var html = "";
          if (mag !== null && !isNaN(mag)) {
            html += "<strong>Gempa M " + mag.toFixed(1) + "</strong>";
          } else {
            html += "<strong>Gempa</strong>";
          }
          if (kedalaman !== null && !isNaN(kedalaman)) {
            html += "<br>Kedalaman " + kedalaman.toFixed(0) + " km";
            if (depthLabel) {
              html += " (" + depthLabel + ")";
            }
          } else if (depthLabel) {
            html += "<br>Kedalaman: " + depthLabel;
          }
          if (tanggal) {
            html += "<br>Tanggal: " + tanggal;
          }
          if (jam) {
            html += "<br>Jam: " + jam + " WIB";
          }
          html += "<br>Sumber: Peta Seismisitas BMKG 2021";
          layer.bindPopup(html);
        }
      });
      updateLayerVisibility();
    }

    function loadSeismicJateng2021Layer() {
      var urlDangkal = buildSeismic2021Url(105);
      var urlMenengah = buildSeismic2021Url(114);
      var urlDalam = buildSeismic2021Url(123);
      setStatus("Memuat seismisitas 2021 BMKG (Jawa Tengah)â€¦", "loading");
      Promise.all([
        fetch(urlDangkal).then(function (r) {
          if (!r.ok) {
            throw new Error("HTTP " + r.status + " Jawa Tengah dangkal");
          }
          return r.json();
        }),
        fetch(urlMenengah).then(function (r) {
          if (!r.ok) {
            throw new Error("HTTP " + r.status + " Jawa Tengah menengah");
          }
          return r.json();
        }),
        fetch(urlDalam).then(function (r) {
          if (!r.ok) {
            throw new Error("HTTP " + r.status + " Jawa Tengah dalam");
          }
          return r.json();
        })
      ])
        .then(function (collections) {
          createSeismicJateng2021Layer(collections);
          setStatus("Seismisitas 2021 BMKG (Jawa Tengah) telah dimuat.", "ok");
        })
        .catch(function (error) {
          setStatus(
            "Gagal memuat seismisitas 2021 BMKG Jawa Tengah: " +
              (error && error.message ? error.message : "galat tak dikenal"),
            "error"
          );
        });
    }

    function loadRoadSectionsLayer() {
      fetch("ruas_jalan.sql")
        .then(function (response) {
          if (!response.ok) {
            throw new Error("HTTP " + response.status + " saat memuat ruas_jalan.sql");
          }
          return response.text();
        })
        .then(function (text) {
          var geojson = parseRuasJalanSql(text);
          createRoadSectionsLayer(geojson);
        })
        .catch(function (error) {
          setStatus(
            "Gagal memuat ruas jalan (SQL): " +
              (error && error.message ? error.message : "galat tak dikenal"),
            "error"
          );
        });
    }

    function loadPlacesLayer() {
      fetch("geojson/tempat.geojson")
        .then(function (response) {
          if (!response.ok) {
            throw new Error("HTTP " + response.status + " saat memuat tempat");
          }
          return response.json();
        })
        .then(function (geojson) {
          createPlacesLayer(geojson);
        })
        .catch(function (error) {
          setStatus(
            "Gagal memuat tempat: " +
              (error && error.message ? error.message : "galat tak dikenal"),
            "error"
          );
        });
    }

    function loadPoisLayer() {
      fetch("geojson/titik-penting.geojson")
        .then(function (response) {
          if (!response.ok) {
            throw new Error("HTTP " + response.status + " saat memuat titik penting");
          }
          return response.json();
        })
        .then(function (geojson) {
          createPoisLayer(geojson);
        })
        .catch(function (error) {
          setStatus(
            "Gagal memuat titik penting: " +
              (error && error.message ? error.message : "galat tak dikenal"),
            "error"
          );
        });
    }

    function loadLandslideRiskLayer() {
      var baseUrl = "https://kspservices.big.go.id/satupeta/rest/services/PUBLIK/SUMBER_DAYA_ALAM_DAN_LINGKUNGAN/MapServer/13/query";
      var bbox =
        banjarnegaraBBox.west + "," +
        banjarnegaraBBox.south + "," +
        banjarnegaraBBox.east + "," +
        banjarnegaraBBox.north;
      var params = new URLSearchParams({
        where: "1=1",
        geometry: bbox,
        geometryType: "esriGeometryEnvelope",
        inSR: "4326",
        spatialRel: "esriSpatialRelIntersects",
        outFields: "*",
        outSR: "4326",
        f: "geojson"
      });

      setStatus("Memuat zona kerentanan gerakan tanah (BIG)â€¦", "loading");

      fetch(baseUrl + "?" + params.toString())
        .then(function (response) {
          if (!response.ok) {
            throw new Error("HTTP " + response.status + " saat memuat zona kerentanan gerakan tanah");
          }
          return response.json();
        })
        .then(function (geojson) {
          if (!geojson || !Array.isArray(geojson.features)) {
            throw new Error("Respon BIG bukan FeatureCollection GeoJSON");
          }
          createLandslideRiskLayer(geojson);
          setStatus("Zona kerentanan gerakan tanah dari BIG telah dimuat.", "ok");
        })
        .catch(function (error) {
          setStatus(
            "Gagal memuat zona kerentanan gerakan tanah: " +
              (error && error.message ? error.message : "galat tak dikenal"),
            "error"
          );
        });
    }

    function loadRainLayer() {
      var baseUrl = "https://gis.bmkg.go.id/arcgis/rest/services/Peta_Hari_Hujan/MapServer/1/query";
      var bbox =
        banjarnegaraBBox.west + "," +
        banjarnegaraBBox.south + "," +
        banjarnegaraBBox.east + "," +
        banjarnegaraBBox.north;
      var params = new URLSearchParams({
        where: "1=1",
        geometry: bbox,
        geometryType: "esriGeometryEnvelope",
        inSR: "4326",
        spatialRel: "esriSpatialRelIntersects",
        outFields: "*",
        outSR: "4326",
        f: "geojson"
      });

      setStatus("Memuat data curah hujan BMKGâ€¦", "loading");

      fetch(baseUrl + "?" + params.toString())
        .then(function (response) {
          if (!response.ok) {
            throw new Error("HTTP " + response.status + " saat memuat curah hujan BMKG");
          }
          return response.json();
        })
        .then(function (geojson) {
          if (!geojson || !Array.isArray(geojson.features)) {
            throw new Error("Respon BMKG bukan FeatureCollection GeoJSON");
          }
          createRainLayer(geojson);
          setStatus("Data curah hujan BMKG telah dimuat.", "ok");
        })
        .catch(function (error) {
          setStatus(
            "Gagal memuat curah hujan BMKG: " +
              (error && error.message ? error.message : "galat tak dikenal"),
            "error"
          );
        });
    }

    function buildClimateProjectionExportUrl(layerId) {
      var bbox =
        banjarnegaraBBox.west + "," +
        banjarnegaraBBox.south + "," +
        banjarnegaraBBox.east + "," +
        banjarnegaraBBox.north;
      var params = new URLSearchParams({
        bbox: bbox,
        bboxSR: "4326",
        imageSR: "4326",
        size: "1024,1024",
        format: "png32",
        transparent: "true",
        f: "image",
        layers: "show:" + layerId
      });
      return "https://gis.bmkg.go.id/arcgis/rest/services/Peta_Proyeksi_Perubahan_Iklim_newww/MapServer/export?" +
        params.toString();
    }

    function createClimateOverlay(url, existingLayer) {
      var southWest = L.latLng(banjarnegaraBBox.south, banjarnegaraBBox.west);
      var northEast = L.latLng(banjarnegaraBBox.north, banjarnegaraBBox.east);
      var bounds = L.latLngBounds(southWest, northEast);
      if (existingLayer) {
        map.removeLayer(existingLayer);
      }
      return L.imageOverlay(url, bounds, {
        opacity: 0.6
      });
    }

    function loadClimateDJFLayer() {
      var url = buildClimateProjectionExportUrl(1580);
      climateDJFLayer = createClimateOverlay(url, climateDJFLayer);
      updateLayerVisibility();
      setStatus("Layer proyeksi iklim DJF BMKG telah ditambahkan.", "ok");
    }

    function loadClimateMAMLayer() {
      var url = buildClimateProjectionExportUrl(1582);
      climateMAMLayer = createClimateOverlay(url, climateMAMLayer);
      updateLayerVisibility();
      setStatus("Layer proyeksi iklim MAM BMKG telah ditambahkan.", "ok");
    }

    function loadClimateJJALayer() {
      var url = buildClimateProjectionExportUrl(1581);
      climateJJALayer = createClimateOverlay(url, climateJJALayer);
      updateLayerVisibility();
      setStatus("Layer proyeksi iklim JJA BMKG telah ditambahkan.", "ok");
    }

    function loadClimateSONLayer() {
      var url = buildClimateProjectionExportUrl(1583);
      climateSONLayer = createClimateOverlay(url, climateSONLayer);
      updateLayerVisibility();
      setStatus("Layer proyeksi iklim SON BMKG telah ditambahkan.", "ok");
    }

    function buildClimateLegend() {
      var container = document.getElementById("climateLegendContainer");
      if (!container) {
        return;
      }
      var url = "https://gis.bmkg.go.id/arcgis/rest/services/Peta_Proyeksi_Perubahan_Iklim_newww/MapServer/legend?f=pjson";
      fetch(url)
        .then(function (response) {
          if (!response.ok) {
            throw new Error("HTTP " + response.status + " saat memuat legenda proyeksi iklim BMKG");
          }
          return response.json();
        })
        .then(function (data) {
          if (!data || !Array.isArray(data.layers) || data.layers.length === 0) {
            throw new Error("Respon legenda BMKG tidak valid");
          }
          container.innerHTML = "";
          var title = document.createElement("div");
          title.textContent = "Nilai perubahan curah hujan (%)";
          title.style.fontSize = "0.75rem";
          title.style.color = "#cbd5f5";
          title.style.marginBottom = "4px";
          container.appendChild(title);

          var table = document.createElement("div");
          table.style.display = "grid";
          table.style.gridTemplateColumns = "auto 1fr";
          table.style.rowGap = "3px";
          table.style.columnGap = "6px";

          var firstLayer = data.layers[0];
          var legends = Array.isArray(firstLayer.legend) ? firstLayer.legend : [];
          for (var i = 0; i < legends.length; i++) {
            var entry = legends[i];
            if (!entry || !entry.imageData) {
              continue;
            }
            var img = document.createElement("img");
            img.src = "data:" + (entry.contentType || "image/png") + ";base64," + entry.imageData;
            img.width = entry.width || 20;
            img.height = entry.height || 20;
            img.style.borderRadius = "4px";
            img.style.border = "1px solid rgba(148,163,184,0.5)";

            var label = document.createElement("div");
            label.textContent = entry.label || "";
            label.style.fontSize = "0.75rem";
            label.style.color = "#e5e7eb";
            label.style.alignSelf = "center";

            table.appendChild(img);
            table.appendChild(label);
          }

          container.appendChild(table);
        })
        .catch(function (error) {
          container.textContent =
            "Gagal memuat legenda BMKG: " +
            (error && error.message ? error.message : "galat tak dikenal");
        });
    }

    // Fungsi untuk membuat legend peta desa
    function buildPetaDesaLegend() {
      var legend = L.control({ position: 'bottomleft' });
      
      legend.onAdd = function(map) {
        var div = L.DomUtil.create('div', 'peta-desa-legend');
        div.innerHTML = '<h4>Legenda Peta Desa</h4>';
        
        // Legend items untuk pattern peta desa
        var patterns = [
          { type: 'sawah', label: 'Sawah', color: '#4ade80' },
          { type: 'hutan_rakyat', label: 'Hutan Rakyat', color: '#16a34a' },
          { type: 'empang', label: 'Empang/Kolam', color: '#0ea5e9' },
          { type: 'sawah_tdh_hujan', label: 'Sawah Tadah Hujan', color: '#f59e0b' },
          { type: 'semak_belukar', label: 'Semak Belukar', color: '#a855f7' }
        ];
        
        patterns.forEach(function(pattern) {
          var item = L.DomUtil.create('div', 'legend-item');
          
          var patternBox = L.DomUtil.create('div', 'legend-pattern');
          patternBox.style.backgroundImage = 'url(assets/patterns/' + pattern.type + '.png)';
          patternBox.style.backgroundSize = '30px 30px';
          patternBox.style.backgroundRepeat = 'repeat';
          patternBox.style.border = '2px solid rgba(255, 255, 255, 0.3)';  // Better visibility
          
          var label = L.DomUtil.create('span');
          label.textContent = pattern.label;
          label.style.fontSize = '12px';
          label.style.marginLeft = '8px';
          label.style.color = '#e5e7eb';  // Light color for better contrast
          
          item.appendChild(patternBox);
          item.appendChild(label);
          div.appendChild(item);
        });
        
        return div;
      };
      
      return legend;
    }

    function loadSoilLayer() {
      fetch("geojson/tanah-jateng.geojson")
        .then(function (response) {
          if (!response.ok) {
            throw new Error("HTTP " + response.status + " saat memuat peta jenis tanah");
          }
          return response.json();
        })
        .then(function (geojson) {
          createSoilLayer(geojson);
          setStatus("Peta jenis tanah Jawa Tengah (tanah_jateng) telah dimuat.", "ok");
        })
        .catch(function (error) {
          setStatus(
            "Gagal memuat peta jenis tanah: " +
              (error && error.message ? error.message : "galat tak dikenal"),
            "error"
          );
        });
    }

    function normalizeQuakeNumber(text) {
      if (typeof text !== "string") {
        if (typeof text === "number") {
          return text;
        }
        return null;
      }
      var cleaned = text.replace(",", ".").replace(/[^\d\.\-]/g, "");
      var value = parseFloat(cleaned);
      if (isNaN(value)) {
        return null;
      }
      return value;
    }

    function createQuakesLayer(features) {
      if (quakesLayer) {
        map.removeLayer(quakesLayer);
        quakesLayer = null;
      }

      var markers = [];
      for (var i = 0; i < features.length; i++) {
        var f = features[i];
        var lat = normalizeQuakeNumber(f.Lintang || f.lintang || f.Lat || f.lat);
        var lng = normalizeQuakeNumber(f.Bujur || f.bujur || f.Lon || f.lon || f.Lng || f.lng);
        if (lat === null || lng === null) {
          continue;
        }
        if (lat < banjarnegaraBBox.south - 1 ||
            lat > banjarnegaraBBox.north + 1 ||
            lng < banjarnegaraBBox.west - 1 ||
            lng > banjarnegaraBBox.east + 1) {
          continue;
        }

        var mag = normalizeQuakeNumber(f.Magnitude || f.magnitude || f.Mag || f.mag);
        var kedalaman = normalizeQuakeNumber(f.Kedalaman || f.kedalaman || f.Depth || f.depth);
        var felt = f.Dirasakan || f.dirasakan || "";
        var waktu = f.Waktu || f.Tanggal || f.Date || "";

        var radius = 5;
        if (mag !== null) {
          radius = 4 + mag * 2;
        }

        var color = "#f97316";
        if (mag !== null) {
          if (mag >= 6) {
            color = "#dc2626";
          } else if (mag >= 5) {
            color = "#ea580c";
          } else if (mag >= 4) {
            color = "#f97316";
          } else {
            color = "#facc15";
          }
        }

        var marker = L.circleMarker([lat, lng], {
          radius: radius,
          color: color,
          weight: 1.5,
          fillColor: color,
          fillOpacity: 0.75
        });

        var html = "";
        if (mag !== null) {
          html += "<strong>Gempa M " + mag.toFixed(1) + "</strong>";
        } else {
          html += "<strong>Gempa dirasakan</strong>";
        }
        if (kedalaman !== null) {
          html += "<br>Kedalaman " + kedalaman.toFixed(0) + " km";
        }
        if (waktu) {
          html += "<br>Waktu: " + waktu;
        }
        if (felt) {
          html += "<br>Dirasakan: " + felt;
        }
        marker.bindPopup(html);
        markers.push(marker);
      }

      quakesLayer = L.layerGroup(markers);
      updateLayerVisibility();
    }

    function loadQuakesLayer() {
      var url = "https://data.bmkg.go.id/DataMKG/TEWS/gempadirasakan.json";
      setStatus("Memuat data gempa dirasakan BMKGâ€¦", "loading");
      fetch(url)
        .then(function (response) {
          if (!response.ok) {
            throw new Error("HTTP " + response.status + " saat memuat gempa BMKG");
          }
          return response.json();
        })
        .then(function (json) {
          var list = [];
          if (json && json.Infogempa && Array.isArray(json.Infogempa.gempa)) {
            list = json.Infogempa.gempa;
          } else if (Array.isArray(json.gempa)) {
            list = json.gempa;
          }
          if (!list.length) {
            throw new Error("Tidak ada data gempa pada respon BMKG");
          }
          createQuakesLayer(list);
          setStatus("Data gempa dirasakan BMKG telah dimuat.", "ok");
        })
        .catch(function (error) {
          setStatus(
            "Gagal memuat gempa BMKG: " +
              (error && error.message ? error.message : "galat tak dikenal"),
            "error"
          );
        });
    }

    function initMap() {
      map = L.map("map", {
        center: [banjarnegaraCenter.lat, banjarnegaraCenter.lng],
        zoom: 11,
        minZoom: 9,
        maxZoom: 17
      });

      map.createPane("soilPane");
      map.getPane("soilPane").style.zIndex = 350;

      map.createPane("landslidePane");
      map.getPane("landslidePane").style.zIndex = 360;

      map.createPane("villagePane");
      map.getPane("villagePane").style.zIndex = 380;

      map.createPane("ewsPane");
      map.getPane("ewsPane").style.zIndex = 410;

      baseLayerOsm = L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 19,
        attribution: "&copy; OpenStreetMap contributors"
      });

      baseLayerSatellite = L.tileLayer("https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}", {
        maxZoom: 19,
        attribution: "Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community"
      });

      baseLayerTopo = L.tileLayer("https://services.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/tile/{z}/{y}/{x}", {
        maxZoom: 19,
        attribution: "Tiles &copy; Esri &mdash; World Topographic Map"
      });

      baseLayerOsm.addTo(map);

      L.control.layers(
        {
          "Peta standar (OSM)": baseLayerOsm,
          "Peta topografi (Esri World Topo)": baseLayerTopo,
          "Citra satelit (Esri World Imagery)": baseLayerSatellite
        },
        {},
        {
          position: "topright"
        }
      ).addTo(map);

      var southWest = L.latLng(banjarnegaraBBox.south, banjarnegaraBBox.west);
      var northEast = L.latLng(banjarnegaraBBox.north, banjarnegaraBBox.east);
      var bounds = L.latLngBounds(southWest, northEast);
      map.fitBounds(bounds);

      map.on("moveend", function () {
        var currentCenter = map.getCenter();
      });
    }

    // Fungsi untuk membuat custom marker dengan font Geosiana
    function createGeosianaMarker(iconChar, className = '') {
      return L.divIcon({
        className: 'geosiana-marker ' + className,
        html: iconChar,
        iconSize: [40, 40],
        iconAnchor: [20, 20],
        popupAnchor: [0, -20]
      });
    }

    // Fungsi untuk menambahkan pattern layer ke peta
    function addPatternLayer(patternType, geojsonData, styleOptions) {
      return L.geoJSON(geojsonData, {
        style: function(feature) {
          return {
            fillColor: styleOptions.color || '#3388ff',
            fillOpacity: 0.6,
            color: styleOptions.borderColor || '#000',
            weight: 1,
            className: 'pattern-' + patternType
          };
        },
        onEachFeature: function(feature, layer) {
          if (feature.properties && feature.properties.name) {
            layer.bindPopup(
              '<div class="custom-popup">' +
              '<h3>' + feature.properties.name + '</h3>' +
              '<p>Tipe: ' + patternType + '</p>' +
              '</div>'
            );
          }
        }
      });
    }

    // Fungsi untuk memuat marker dari localStorage
    function loadGeosianaMarkers() {
      console.log('Loading Geosiana markers from localStorage...');
      const savedMarkers = localStorage.getItem('geosianaMarkers');
      console.log('Raw localStorage data:', savedMarkers);
      
      if (savedMarkers) {
        try {
          const markers = JSON.parse(savedMarkers);
          console.log('Parsed markers:', markers);
          console.log('Number of markers:', markers.length);
          
          markers.forEach(markerData => {
            console.log('Adding marker:', markerData);
            addGeosianaMarkerToMap(markerData);
          });
          
          console.log('Loaded', markers.length, 'Geosiana markers');
        } catch (error) {
          console.error('Error loading markers:', error);
        }
      } else {
        console.log('No Geosiana markers found in localStorage');
      }
    }

    // Fungsi untuk membuat custom marker Geosiana
    function createGeosianaMarker(iconChar, className = '', color = 'blue') {
      // Dapatkan tipe font dari className
      const fontType = className.includes('extra') ? 'extra' : 
                      className.includes('forestry') ? 'forestry' :
                      className.includes('animal') ? 'animal' : 'default';
      
      // Dapatkan font family yang sesuai
      const fontFamily = fontType === 'extra' ? 'Geosiana Extra' :
                        fontType === 'forestry' ? 'Geosiana Forestry' :
                        fontType === 'animal' ? 'Geosiana Animal' : 'Geosiana Default';
      
      return L.divIcon({
        className: 'geosiana-marker ' + className + ' ' + color,
        html: `<div style="font-family: '${fontFamily}', sans-serif; font-size: 32px; width: 40px; height: 40px; display: flex; align-items: center; justify-content: center; text-align: center;">${iconChar}</div>`,
        iconSize: [40, 40],
        iconAnchor: [20, 20],
        popupAnchor: [0, -20]
      });
    }

    // Fungsi untuk menambahkan marker ke peta
    function addGeosianaMarkerToMap(markerData) {
      console.log('Creating marker with data:', markerData);
      
      try {
        const icon = createGeosianaMarker(markerData.char, markerData.type, markerData.color);
        console.log('Marker icon created:', icon);
        
        const marker = L.marker([markerData.lat, markerData.lng], {
          icon: icon
        }).addTo(map);

        console.log('Marker added to map at:', markerData.lat, markerData.lng);

        marker.bindPopup(`
          <div class="custom-popup">
            <div style="background-color: #3b82f6; color: white; padding: 8px 12px; margin: -8px -12px 12px -12px; border-radius: 4px 4px 0 0;">
              <strong>${markerData.name}</strong>
            </div>
            <p><strong>Type:</strong> ${markerData.type}</p>
            <p>${markerData.description}</p>
            <p><small>Lat: ${markerData.lat.toFixed(4)}, Lng: ${markerData.lng.toFixed(4)}</small></p>
          </div>
        `);
        
        console.log('Popup bound to marker');
      } catch (error) {
        console.error('Error creating marker:', error, markerData);
      }
    }

    document.addEventListener("DOMContentLoaded", function () {
      initMap();
      buildClimateLegend();
      
      // Muat marker Geosiana dari localStorage
      loadGeosianaMarkers();
      
      // Tambahkan legend peta desa
      var petaDesaLegend = buildPetaDesaLegend();
      petaDesaLegend.addTo(map);
      
      // Contoh penggunaan custom marker dengan font Geosiana
      setTimeout(function() {
        // Contoh marker dengan ikon Geosiana
        var sampleMarker = L.marker([-7.3911, 109.6632], {
          icon: createGeosianaMarker('A', 'success') // 'A' adalah contoh karakter dari font Geosiana
        }).addTo(map);
        
        sampleMarker.bindPopup(
          '<div class="custom-popup">' +
          '<h3>Contoh Marker Geosiana</h3>' +
          '<p>Menggunakan font Geosiana Default</p>' +
          '<p>Karakter: A</p>' +
          '</div>'
        );
      }, 1000);
      
      fetchBmkgNowcastForProvince();
      if (filterEwsCheckbox) {
        filterEwsCheckbox.checked = true;
      }
      if (filterEwsFloodCheckbox) {
        filterEwsFloodCheckbox.checked = true;
      }
      if (filterEwsGeoCheckbox) {
        filterEwsGeoCheckbox.checked = true;
      }
      if (filterEwsQuakeTypeCheckbox) {
        filterEwsQuakeTypeCheckbox.checked = true;
      }
      if (filterEwsMagmaCheckbox) {
        filterEwsMagmaCheckbox.checked = true;
      }
      if (filterEwsWeatherCheckbox) {
        filterEwsWeatherCheckbox.checked = true;
      }
      loadEwsLayer();
      refreshButton.addEventListener("click", function () {
        if (filterRiversCheckbox) {
          filterRiversCheckbox.checked = true;
        }
        loadWaterData();
      });

      if (filterRiversCheckbox) {
        filterRiversCheckbox.addEventListener("change", function () {
          if (filterRiversCheckbox.checked) {
            if (
              !waterRiversLayer &&
              !waterLakesLayer &&
              !waterIrrigationLayer
            ) {
              loadWaterData();
            } else {
              updateLayerVisibility();
            }
          } else {
            updateLayerVisibility();
          }
        });
      }

      if (filterLakesCheckbox) {
        filterLakesCheckbox.addEventListener("change", function () {
          updateLayerVisibility();
        });
      }

      if (filterIrrigationCheckbox) {
        filterIrrigationCheckbox.addEventListener("change", function () {
          updateLayerVisibility();
        });
      }

      if (filterVillagesCheckbox) {
        filterVillagesCheckbox.addEventListener("change", function () {
          if (filterVillagesCheckbox.checked && !villageLayer) {
            loadVillageBoundaries();
          } else {
            updateLayerVisibility();
          }
        });
      }
      if (filterLocalRiversCheckbox) {
        filterLocalRiversCheckbox.addEventListener("change", function () {
          if (filterLocalRiversCheckbox.checked && !localRiversLayer) {
            loadLocalRiversLayer();
          } else {
            updateLayerVisibility();
          }
        });
      }
      if (filterRainCheckbox) {
        filterRainCheckbox.addEventListener("change", function () {
          if (filterRainCheckbox.checked && !rainLayer) {
            loadRainLayer();
          } else {
            updateLayerVisibility();
          }
        });
      }
      if (filterQuakesCheckbox) {
        filterQuakesCheckbox.addEventListener("change", function () {
          if (filterQuakesCheckbox.checked && !quakesLayer) {
            loadQuakesLayer();
          } else {
            updateLayerVisibility();
          }
        });
      }
      if (filterSeismicJateng2021Checkbox) {
        filterSeismicJateng2021Checkbox.addEventListener("change", function () {
          if (filterSeismicJateng2021Checkbox.checked && !seismicJateng2021Layer) {
            loadSeismicJateng2021Layer();
          } else {
            updateLayerVisibility();
          }
        });
      }
      if (filterClimateDJFCheckbox) {
        filterClimateDJFCheckbox.addEventListener("change", function () {
          if (filterClimateDJFCheckbox.checked && !climateDJFLayer) {
            loadClimateDJFLayer();
          } else {
            updateLayerVisibility();
          }
        });
      }
      if (filterClimateMAMCheckbox) {
        filterClimateMAMCheckbox.addEventListener("change", function () {
          if (filterClimateMAMCheckbox.checked && !climateMAMLayer) {
            loadClimateMAMLayer();
          } else {
            updateLayerVisibility();
          }
        });
      }
      if (filterClimateJJACheckbox) {
        filterClimateJJACheckbox.addEventListener("change", function () {
          if (filterClimateJJACheckbox.checked && !climateJJALayer) {
            loadClimateJJALayer();
          } else {
            updateLayerVisibility();
          }
        });
      }
      if (filterClimateSONCheckbox) {
        filterClimateSONCheckbox.addEventListener("change", function () {
          if (filterClimateSONCheckbox.checked && !climateSONLayer) {
            loadClimateSONLayer();
          } else {
            updateLayerVisibility();
          }
        });
      }
      if (filterEwsCheckbox) {
        filterEwsCheckbox.addEventListener("change", function () {
          if (filterEwsCheckbox.checked && !ewsLayer && !ewsData) {
            loadEwsLayer();
          } else {
            updateLayerVisibility();
          }
        });
      }
      if (filterLandslideRiskCheckbox) {
        filterLandslideRiskCheckbox.addEventListener("change", function () {
          if (filterLandslideRiskCheckbox.checked && !landslideRiskLayer) {
            loadLandslideRiskLayer();
          } else {
            updateLayerVisibility();
          }
        });
      }
      if (filterRoadSectionsCheckbox) {
        filterRoadSectionsCheckbox.addEventListener("change", function () {
          if (filterRoadSectionsCheckbox.checked && !roadSectionsLayer) {
            loadRoadSectionsLayer();
          } else {
            updateLayerVisibility();
          }
        });
      }
      function attachEwsTypeListener(cb) {
        if (!cb) {
          return;
        }
        cb.addEventListener("change", function () {
          if (ewsData) {
            rebuildEwsLayer();
          }
        });
      }
      attachEwsTypeListener(filterEwsFloodCheckbox);
      attachEwsTypeListener(filterEwsGeoCheckbox);
      attachEwsTypeListener(filterEwsQuakeTypeCheckbox);
      attachEwsTypeListener(filterEwsMagmaCheckbox);
      attachEwsTypeListener(filterEwsWeatherCheckbox);
      if (filterRoadsCheckbox) {
        filterRoadsCheckbox.addEventListener("change", function () {
          if (filterRoadsCheckbox.checked && !roadsLayer) {
            loadRoadsLayer();
          } else {
            updateLayerVisibility();
          }
        });
      }
      if (filterContoursCheckbox) {
        filterContoursCheckbox.addEventListener("change", function () {
          if (filterContoursCheckbox.checked && !contourLayer) {
            loadContourLayer();
          } else {
            updateLayerVisibility();
          }
        });
      }
      if (filterBuildingsCheckbox) {
        filterBuildingsCheckbox.addEventListener("change", function () {
          if (filterBuildingsCheckbox.checked && !buildingsLayer) {
            loadBuildingsLayer();
          } else {
            updateLayerVisibility();
          }
        });
      }
      if (filterNaturalCheckbox) {
        filterNaturalCheckbox.addEventListener("change", function () {
          if (filterNaturalCheckbox.checked && !naturalLayer) {
            loadNaturalLayer();
          } else {
            updateLayerVisibility();
          }
        });
      }
      if (filterPlacesCheckbox) {
        filterPlacesCheckbox.addEventListener("change", function () {
          if (filterPlacesCheckbox.checked && !placesLayer) {
            loadPlacesLayer();
          } else {
            updateLayerVisibility();
          }
        });
      }
      if (filterPoisCheckbox) {
        filterPoisCheckbox.addEventListener("change", function () {
          if (filterPoisCheckbox.checked && !poisLayer) {
            loadPoisLayer();
          } else {
            updateLayerVisibility();
          }
        });
      }

      // Disaster checkbox event listeners
      if (filterKebakaranCheckbox) {
        filterKebakaranCheckbox.addEventListener("change", function () {
          console.log('Kebakaran checkbox changed:', this.checked);
          updateDisasterLayerVisibility();
        });
      }
      if (filterLongsorCheckbox) {
        filterLongsorCheckbox.addEventListener("change", function () {
          console.log('Longsor checkbox changed:', this.checked);
          updateDisasterLayerVisibility();
        });
      }
      if (filterAnginCheckbox) {
        filterAnginCheckbox.addEventListener("change", function () {
          console.log('Angin checkbox changed:', this.checked);
          updateDisasterLayerVisibility();
        });
      }
      if (filterPohonCheckbox) {
        filterPohonCheckbox.addEventListener("change", function () {
          console.log('Pohon checkbox changed:', this.checked);
          updateDisasterLayerVisibility();
        });
      }
      if (filterOrangHilangCheckbox) {
        filterOrangHilangCheckbox.addEventListener("change", function () {
          console.log('Orang Hilang checkbox changed:', this.checked);
          updateDisasterLayerVisibility();
        });
      }
      if (filterAllBencanaCheckbox) {
        filterAllBencanaCheckbox.addEventListener("change", function () {
          console.log('Pilih Semua checkbox changed:', this.checked);
          // Select/deselect all disaster checkboxes
          const isChecked = filterAllBencanaCheckbox.checked;
          if (filterKebakaranCheckbox) filterKebakaranCheckbox.checked = isChecked;
          if (filterLongsorCheckbox) filterLongsorCheckbox.checked = isChecked;
          if (filterAnginCheckbox) filterAnginCheckbox.checked = isChecked;
          if (filterPohonCheckbox) filterPohonCheckbox.checked = isChecked;
          if (filterOrangHilangCheckbox) filterOrangHilangCheckbox.checked = isChecked;
          updateDisasterLayerVisibility();
        });
      }
      if (filterGroundwaterCheckbox) {
        filterGroundwaterCheckbox.addEventListener("change", function () {
          if (filterGroundwaterCheckbox.checked && !groundwaterLayer) {
            loadGroundwaterLayer();
          } else {
            updateLayerVisibility();
          }
        });
      }
      if (filterSoilCheckbox) {
        filterSoilCheckbox.addEventListener("change", function () {
          if (filterSoilCheckbox.checked && !soilLayer) {
            loadSoilLayer();
          } else {
            updateLayerVisibility();
          }
        });
      }

      if (exportButton) {
        exportButton.addEventListener("click", function () {
          if (!lastGeoJson) {
            alert("Data air permukaan belum tersedia. Silakan muat data terlebih dahulu.");
            return;
          }

          var blob = new Blob([JSON.stringify(lastGeoJson)], {
            type: "application/vnd.geo+json;charset=utf-8"
          });
          var url = URL.createObjectURL(blob);
          var link = document.createElement("a");
          link.href = url;
          link.download = "banjarnegara-air-permukaan.geojson";
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          URL.revokeObjectURL(url);
        });
      }

      if (geojsonFileInput && loadLocalGeojsonButton) {
        loadLocalGeojsonButton.addEventListener("click", function () {
          geojsonFileInput.click();
        });

        geojsonFileInput.addEventListener("change", function (event) {
          var file = event.target.files && event.target.files[0] ? event.target.files[0] : null;
          if (!file) {
            return;
          }

          setStatus("Memuat GeoJSON lokalâ€¦", "loading");

          var reader = new FileReader();
          reader.onload = function () {
            try {
              var text = reader.result || "";
              var parsed = JSON.parse(text);
              if (!parsed || parsed.type !== "FeatureCollection" || !Array.isArray(parsed.features)) {
                throw new Error("Format bukan FeatureCollection GeoJSON");
              }
              loadGeoJSONObject(parsed, "berkas GeoJSON lokal");
            } catch (err) {
              setStatus("Gagal memuat GeoJSON lokal: " + (err && err.message ? err.message : "galat tak dikenal"), "error");
            }
          };
          reader.onerror = function () {
            setStatus("Gagal membaca berkas GeoJSON lokal.", "error");
          };
          reader.readAsText(file);
        });
      }

      // Automatically load disaster GeoJSON data
      // Disaster data will be loaded on-demand when checkboxes are checked
    });
  </script>
</body>
</html>

